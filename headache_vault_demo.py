import streamlit as st
import pandas as pd
import json
import re
import requests
from datetime import datetime
from data_flow import SessionStateManager, SidebarHelper, SearchService, PAGenerator
from enum import Enum
from dataclasses import dataclass, field
from typing import Optional, List, Tuple

# ============================================================================
# EMAIL INTEGRATION - Resend API for PA delivery and lead capture
# ============================================================================

def send_pa_email(recipient_email: str, pa_text: str, patient_info: dict, notify_launch: bool = False) -> tuple[bool, str]:
    """
    Send PA letter via Resend API and optionally add to marketing list.
    
    Args:
        recipient_email: User's email address
        pa_text: The generated PA letter text
        patient_info: Dict with drug, payer, state, diagnosis for email context
        notify_launch: Whether user opted in to launch notifications
    
    Returns:
        Tuple of (success: bool, message: str)
    """
    try:
        import resend
        
        # Get API key from Streamlit secrets
        if "RESEND_API_KEY" not in st.secrets:
            return False, "Email service not configured. Please copy the PA text instead."
        
        resend.api_key = st.secrets["RESEND_API_KEY"]
        
        # Build HTML email
        drug = patient_info.get('drug', 'CGRP medication')
        payer = patient_info.get('payer', 'Insurance')
        state = patient_info.get('state', '')
        diagnosis = patient_info.get('diagnosis', 'Migraine')
        
        # Convert PA text to HTML (preserve formatting)
        pa_html = pa_text.replace('\n', '<br>').replace(' ', '&nbsp;' if '  ' in pa_text else ' ')
        
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #1f2937; }}
        .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
        .header {{ background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%); color: white; padding: 24px; border-radius: 12px 12px 0 0; }}
        .header h1 {{ margin: 0; font-size: 24px; }}
        .header p {{ margin: 8px 0 0 0; opacity: 0.9; font-size: 14px; }}
        .content {{ background: #f9fafb; border: 1px solid #e5e7eb; border-top: none; padding: 24px; border-radius: 0 0 12px 12px; }}
        .pa-letter {{ background: white; border: 1px solid #d1d5db; border-radius: 8px; padding: 20px; font-family: 'Courier New', monospace; font-size: 13px; white-space: pre-wrap; line-height: 1.5; }}
        .summary {{ background: #eff6ff; border: 1px solid #bfdbfe; border-radius: 8px; padding: 16px; margin-bottom: 20px; }}
        .summary-title {{ font-weight: 600; color: #1e40af; margin-bottom: 8px; }}
        .summary-item {{ color: #374151; font-size: 14px; }}
        .footer {{ text-align: center; padding: 20px; color: #6b7280; font-size: 12px; }}
        .footer a {{ color: #6366f1; text-decoration: none; }}
        .tips {{ background: #fef3c7; border: 1px solid #fcd34d; border-radius: 8px; padding: 16px; margin-top: 20px; }}
        .tips-title {{ font-weight: 600; color: #92400e; margin-bottom: 8px; }}
        .tips-content {{ color: #78350f; font-size: 13px; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìã Your Prior Authorization Letter</h1>
            <p>Generated by Headache Vault</p>
        </div>
        <div class="content">
            <div class="summary">
                <div class="summary-title">Request Summary</div>
                <div class="summary-item"><strong>Medication:</strong> {drug}</div>
                <div class="summary-item"><strong>Payer:</strong> {payer}</div>
                <div class="summary-item"><strong>State:</strong> {state}</div>
                <div class="summary-item"><strong>Diagnosis:</strong> {diagnosis}</div>
            </div>
            
            <div class="pa-letter">{pa_text}</div>
            
            <div class="tips">
                <div class="tips-title">üí° Submission Tips</div>
                <div class="tips-content">
                    ‚Ä¢ Review and customize patient-specific details before submitting<br>
                    ‚Ä¢ Include supporting documentation (office notes, headache diary)<br>
                    ‚Ä¢ Keep a copy for your records with submission date<br>
                    ‚Ä¢ Follow up if no response within the payer's stated turnaround time
                </div>
            </div>
        </div>
        <div class="footer">
            <p>This PA letter was generated using <a href="https://headachevault.com">Headache Vault</a></p>
            <p>Questions? Reply to this email or visit headachevault.com</p>
            <p style="margin-top: 16px; font-size: 11px; color: #9ca3af;">
                ¬© 2026 Headache Vault ‚Ä¢ Built by a migraine patient, for the headache community
            </p>
        </div>
    </div>
</body>
</html>
"""
        
        # Send the email
        email_params = {
            "from": "Headache Vault <alex.doty@headachevault.com>",
            "to": [recipient_email],
            "subject": "Your Prior Authorization Letter - Headache Vault",
            "html": html_content,
            "text": f"Your Prior Authorization Letter\n\nGenerated by Headache Vault\n\n{'-'*50}\n\n{pa_text}\n\n{'-'*50}\n\nVisit headachevault.com for more PA automation tools."
        }
        
        result = resend.Emails.send(email_params)
        
        # If user opted in to launch notifications, add to audience
        if notify_launch:
            try:
                # Check if RESEND_AUDIENCE_ID is configured
                if "RESEND_AUDIENCE_ID" in st.secrets:
                    resend.Contacts.create(
                        audience_id=st.secrets["RESEND_AUDIENCE_ID"],
                        email=recipient_email,
                        unsubscribed=False
                    )
            except Exception as audience_error:
                # Don't fail the whole operation if audience add fails
                print(f"Failed to add to audience: {audience_error}")
        
        return True, "PA letter sent! Check your inbox."
        
    except ImportError:
        return False, "Email library not installed. Please copy the PA text instead."
    except Exception as e:
        error_msg = str(e)
        if "invalid_api_key" in error_msg.lower():
            return False, "Email service configuration error. Please copy the PA text instead."
        elif "validation" in error_msg.lower():
            return False, "Please enter a valid email address."
        else:
            return False, f"Failed to send email. Please copy the PA text instead."


def show_email_modal():
    """Display email capture modal in sidebar or expander."""
    if 'pa_text_for_email' not in st.session_state or not st.session_state.pa_text_for_email:
        return
    
    with st.expander("üìß Email this PA to yourself", expanded=st.session_state.get('show_email_form', False)):
        st.markdown("""
        <div style="font-size: 0.9rem; color: #4b5563; margin-bottom: 12px;">
            Get a formatted copy of this PA letter delivered to your inbox.
        </div>
        """, unsafe_allow_html=True)
        
        email_input = st.text_input(
            "Email address",
            placeholder="you@clinic.com",
            key="email_capture_input",
            label_visibility="collapsed"
        )
        
        notify_launch = st.checkbox(
            "Notify me when Headache Vault launches",
            value=True,
            key="notify_launch_checkbox",
            help="We'll send you one email when the full platform is available. No spam, ever."
        )
        
        col1, col2 = st.columns([2, 1])
        with col1:
            if st.button("üì® Send PA", key="send_email_btn", use_container_width=True):
                if not email_input or '@' not in email_input:
                    st.error("Please enter a valid email address")
                else:
                    with st.spinner("Sending..."):
                        success, message = send_pa_email(
                            recipient_email=email_input,
                            pa_text=st.session_state.pa_text_for_email,
                            patient_info=st.session_state.get('pa_email_context', {}),
                            notify_launch=notify_launch
                        )
                    
                    if success:
                        st.success(f"‚úÖ {message}")
                        st.session_state.show_email_form = False
                        # Track successful capture
                        if 'email_captures' not in st.session_state:
                            st.session_state.email_captures = []
                        st.session_state.email_captures.append({
                            'email': email_input,
                            'notify_launch': notify_launch,
                            'timestamp': datetime.now().isoformat()
                        })
                    else:
                        st.error(f"‚ùå {message}")
        
        with col2:
            if st.button("Cancel", key="cancel_email_btn", use_container_width=True):
                st.session_state.show_email_form = False
                st.rerun()
        
        st.markdown("""
        <div style="font-size: 0.75rem; color: #9ca3af; margin-top: 8px;">
            We'll never spam you. Unsubscribe anytime.
        </div>
        """, unsafe_allow_html=True)

# ============================================================================
# ERROR MESSAGING SYSTEM v2 - Clean, Actionable Error Messages
# ============================================================================

class ErrorSeverity(Enum):
    """Error severity levels"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"


@dataclass  
class ErrorMessage:
    """Simple, actionable error message"""
    severity: ErrorSeverity
    title: str
    description: str
    actions: List[str]
    appeal_tip: Optional[str] = None
    
    def __str__(self):
        """Default string representation"""
        icon = {"info": "‚ÑπÔ∏è", "warning": "‚ö†Ô∏è", "error": "‚ùå"}[self.severity.value]
        lines = [
            f"{icon} {self.title}",
            "",
            self.description,
            "",
            "What to do:"
        ]
        lines.extend(f"  ‚Ä¢ {action}" for action in self.actions)
        
        if self.appeal_tip:
            lines.extend(["", f"üí° Appeal Tip: {self.appeal_tip}"])
        
        return "\n".join(lines)


def create_error(error_type: str, **context) -> ErrorMessage:
    """Create error message based on type and context"""
    
    errors = {
        # Medication errors
        "med_not_found": ErrorMessage(
            severity=ErrorSeverity.ERROR,
            title="Medication Not Recognized",
            description=f"We couldn't find '{context.get('medication', 'this medication')}' in our database.",
            actions=[
                "Check spelling (e.g., 'propranolol' not 'propanolol')",
                "Try brand name (e.g., 'Aimovig') or generic (e.g., 'erenumab')",
                "Remove dosage info (e.g., 'Aimovig' not 'Aimovig 70mg')"
            ]
        ),
        
        # Step therapy errors
        "insufficient_trials": ErrorMessage(
            severity=ErrorSeverity.ERROR,
            title="Need More Preventive Medication Trials",
            description=f"Documented {context.get('current', 1)} preventive class(es), need {context.get('required', 2)}.",
            actions=[
                f"Add trials from: {context.get('missing', 'Anticonvulsant, TCA, or SNRI')}",
                "Each trial needs: ‚â•8 weeks at therapeutic dose",
                "Document why stopped (side effects, didn't work, contraindication)",
                "Examples: topiramate 100mg, propranolol 80mg, amitriptyline 50mg"
            ],
            appeal_tip="If patient can't tolerate required meds (side effects, contraindications), document this clearly and cite AHS guidelines"
        ),
        
        "low_doses": ErrorMessage(
            severity=ErrorSeverity.WARNING,
            title="Medication Doses May Be Too Low",
            description="Some preventive trials may not have reached therapeutic dose.",
            actions=[
                "Propranolol: ‚â•80mg/day",
                "Topiramate: ‚â•100mg/day",
                "Amitriptyline: ‚â•50mg/day",
                "Document reason if lower dose used (e.g., side effects prevented increase)"
            ],
            appeal_tip="Explain that patient couldn't tolerate higher doses due to specific side effects"
        ),
        
        "short_trials": ErrorMessage(
            severity=ErrorSeverity.WARNING,
            title="Medication Trials May Be Too Short",
            description="AHS guidelines recommend ‚â•8 week trials for preventive medications.",
            actions=[
                "Document each medication was tried for ‚â•8 weeks",
                "If stopped early, explain why (severe side effects, allergic reaction)",
                "Include specific dates: started X, stopped Y due to Z"
            ],
            appeal_tip="Early discontinuation due to intolerable side effects is acceptable - document clearly"
        ),
        
        # Frequency errors
        "frequency_low": ErrorMessage(
            severity=ErrorSeverity.ERROR,
            title="Headache Frequency Below Threshold",
            description=f"Documented {context.get('current', 0)} days/month, payer requires ‚â•{context.get('required', 4)} days/month.",
            actions=[
                "Verify frequency from 3-month headache diary",
                "Document disability: MIDAS score (>21 = severe), HIT-6 score (>60 = severe impact)",
                "Note missed work/school days",
                "If truly <4 days/month, consider acute treatment (Ubrelvy, Nurtec) instead"
            ],
            appeal_tip=f"Emphasize impact over frequency. Include MIDAS{' score ' + context.get('midas', '') if context.get('midas') else ''} showing severe disability despite lower frequency"
        ),
        
        "frequency_missing": ErrorMessage(
            severity=ErrorSeverity.ERROR,
            title="Headache Frequency Not Documented",
            description="PA requires headache frequency (days per month).",
            actions=[
                "Add: 'Patient has [X] headache days per month'",
                "Base on patient diary or 3-month recall",
                "Include assessment period (e.g., 'over past 3 months')"
            ]
        ),
        
        # Diagnosis errors
        "wrong_diagnosis": ErrorMessage(
            severity=ErrorSeverity.ERROR,
            title="Diagnosis Code Issue",
            description="ICD-10 code may not match requested medication.",
            actions=[
                "Chronic migraine (‚â•15 days/month): G43.709 or G43.719",
                "Episodic migraine (4-14 days/month): G43.909",
                "Cluster headache: G44.009",
                "Botox REQUIRES chronic migraine diagnosis (‚â•15 days/month)"
            ]
        ),
        
        "botox_needs_chronic": ErrorMessage(
            severity=ErrorSeverity.ERROR,
            title="Botox Requires Chronic Migraine",
            description="Botox is only approved for chronic migraine (‚â•15 headache days/month for ‚â•3 months).",
            actions=[
                "If patient has <15 days/month, request CGRP mAb instead (Aimovig, Emgality, Ajovy)",
                "If patient has ‚â•15 days/month, update diagnosis to G43.709 or G43.719",
                "Document frequency from 3-month diary"
            ]
        ),
        
        # Helpful bypass info
        "cv_bypass": ErrorMessage(
            severity=ErrorSeverity.INFO,
            title="‚úì CV Contraindication Bypass Available",
            description="Patient has cardiovascular condition - first-line CGRP/gepant may be approved without full step therapy.",
            actions=[
                "Document CV diagnosis: CAD, stroke, uncontrolled HTN, peripheral vascular disease",
                "Note contraindication to triptans (FDA labeling)",
                "Reference AHS 2024 guidelines supporting gepants in CV patients",
                "Bypass approved - may not need 2-3 preventive failures"
            ],
            appeal_tip="Cite specific CV condition and safety data for gepants/CGRPs in cardiovascular population"
        ),
        
        "pregnancy_bypass": ErrorMessage(
            severity=ErrorSeverity.INFO,
            title="‚úì Teratogen Bypass Available",
            description="Patient is female of childbearing age - can skip teratogenic preventives.",
            actions=[
                "Document patient is female, age 12-55",
                "Note contraindication to valproate (FDA Category X) and topiramate (FDA Category D)",
                "Can proceed to CGRP without trying these medications",
                "Reference FDA pregnancy warnings"
            ],
            appeal_tip="Teratogenic risk makes valproate/topiramate inappropriate - CGRP represents safer alternative"
        ),
        
        "moh_risk": ErrorMessage(
            severity=ErrorSeverity.WARNING,
            title="Medication Overuse Headache Risk Detected",
            description=f"Patient using acute meds ‚â•{context.get('frequency', 10)} days/month - MOH risk.",
            actions=[
                "Document acute medication frequency (triptan/NSAID/combination analgesic days/month)",
                "Note this increases urgency for preventive therapy",
                "Include in PA justification: 'Patient at high risk for MOH, preventive therapy urgent'",
                "Preventive therapy helps reduce acute medication use"
            ],
            appeal_tip="High MOH risk strengthens case for preventive therapy urgency"
        ),
        
        # Success messages
        "approved": ErrorMessage(
            severity=ErrorSeverity.INFO,
            title="‚úì PA Ready to Submit",
            description="All requirements met. PA looks good!",
            actions=[
                "Review generated PA for accuracy",
                "Add any additional clinical details",
                "Submit to payer (portal, fax, or electronic)",
                "Follow up in 5-7 business days"
            ]
        ),
        
        "strong_pa": ErrorMessage(
            severity=ErrorSeverity.INFO,
            title="‚úì Strong PA - High Approval Probability",
            description="Excellent documentation. Expected approval rate >90%.",
            actions=[
                "Consider expedited review if urgent",
                "Have follow-up plan ready",
                "Track submission for timely response"
            ]
        ),
        
        # System errors
        "payer_not_found": ErrorMessage(
            severity=ErrorSeverity.WARNING,
            title="Payer Policy Not in Database",
            description=f"We don't have specific policy for '{context.get('payer', 'this payer')}'.",
            actions=[
                "Using national commercial insurance criteria as fallback",
                "Verify insurance name spelling",
                "Check payer's formulary directly for specific requirements",
                "Contact us to add this payer to database"
            ]
        ),
        
        # State not selected
        "state_required": ErrorMessage(
            severity=ErrorSeverity.ERROR,
            title="State Selection Required",
            description="Please select a state to search for payer policies.",
            actions=[
                "Select the patient's state from the sidebar dropdown",
                "This determines which payer policies apply",
                "Policies vary significantly by state"
            ]
        ),
        
        # Age not detected
        "age_not_detected": ErrorMessage(
            severity=ErrorSeverity.WARNING,
            title="Patient Age Not Detected",
            description="Age is needed to check pediatric restrictions and dosing.",
            actions=[
                "Enter patient age in the sidebar",
                "Pediatric patients (<18) have different FDA approvals",
                "Some medications require weight-based dosing for children"
            ]
        ),
    }
    
    return errors.get(error_type, ErrorMessage(
        severity=ErrorSeverity.ERROR,
        title="Unknown Error",
        description=f"Error type '{error_type}' not recognized.",
        actions=["Contact support for assistance"]
    ))


def render_error_message(error: ErrorMessage, expanded: bool = True):
    """Render an ErrorMessage using Streamlit components with nice formatting."""
    
    # Color schemes by severity
    colors = {
        ErrorSeverity.INFO: {
            "bg": "#E0F2FE",      # Light blue
            "border": "#0EA5E9",   # Blue
            "text": "#0369A1",     # Dark blue
            "icon": "‚ÑπÔ∏è"
        },
        ErrorSeverity.WARNING: {
            "bg": "#FEF3C7",      # Light yellow
            "border": "#F59E0B",   # Amber
            "text": "#92400E",     # Dark amber
            "icon": "‚ö†Ô∏è"
        },
        ErrorSeverity.ERROR: {
            "bg": "#FEE2E2",      # Light red
            "border": "#EF4444",   # Red
            "text": "#991B1B",     # Dark red
            "icon": "‚ùå"
        }
    }
    
    c = colors[error.severity]
    
    # Build actions list HTML
    actions_html = "".join([f"<li style='margin-bottom: 4px;'>{action}</li>" for action in error.actions])
    
    # Appeal tip HTML (if present)
    appeal_html = ""
    if error.appeal_tip:
        appeal_html = f"""
        <div style="background: #F0FDF4; border-left: 3px solid #22C55E; padding: 8px 12px; margin-top: 12px; border-radius: 4px;">
            <strong style="color: #166534;">üí° Appeal Tip:</strong>
            <span style="color: #166534;">{error.appeal_tip}</span>
        </div>
        """
    
    # Full message HTML
    html = f"""
    <div style="background: {c['bg']}; border: 1px solid {c['border']}; border-left: 4px solid {c['border']}; 
                border-radius: 8px; padding: 16px; margin: 12px 0;">
        <div style="font-weight: 700; color: {c['text']}; font-size: 1.05rem; margin-bottom: 8px;">
            {c['icon']} {error.title}
        </div>
        <div style="color: {c['text']}; margin-bottom: 12px;">
            {error.description}
        </div>
        <div style="color: {c['text']};">
            <strong>What to do:</strong>
            <ul style="margin: 8px 0 0 0; padding-left: 20px;">
                {actions_html}
            </ul>
        </div>
        {appeal_html}
    </div>
    """
    
    st.markdown(html, unsafe_allow_html=True)


def show_error(error_type: str, **context):
    """Convenience function: create and render an error in one call."""
    error = create_error(error_type, **context)
    render_error_message(error)
    return error


# ============================================================================
# MEDICATION NAME MATCHER - Handles brand names, generics, misspellings
# ============================================================================

class MedicationMatcher:
    """
    Robust medication name matching with fuzzy logic
    Handles: brand names, generics, misspellings, common variations
    """
    
    def __init__(self):
        from difflib import SequenceMatcher
        self.SequenceMatcher = SequenceMatcher
        
        # Comprehensive medication alias database
        self.medication_db = {
            # CGRP Monoclonal Antibodies
            "aimovig": {
                "generic": "erenumab",
                "brand": "Aimovig",
                "drug_class": "CGRP mAbs",
                "aliases": ["erenumab", "aimovig", "erenumab-aooe"],
                "common_misspellings": ["aimovag", "aimovig", "erenomab", "erenumob"]
            },
            "emgality": {
                "generic": "galcanezumab",
                "brand": "Emgality",
                "drug_class": "CGRP mAbs",
                "aliases": ["galcanezumab", "emgality", "galcanezumab-gnlm"],
                "common_misspellings": ["emgalaty", "galcanezumob", "galcanezemab"]
            },
            "ajovy": {
                "generic": "fremanezumab",
                "brand": "Ajovy",
                "drug_class": "CGRP mAbs",
                "aliases": ["fremanezumab", "ajovy", "fremanezumab-vfrm"],
                "common_misspellings": ["ajovey", "fremanezemab", "fremanezumob"]
            },
            "vyepti": {
                "generic": "eptinezumab",
                "brand": "Vyepti",
                "drug_class": "CGRP mAbs",
                "aliases": ["eptinezumab", "vyepti", "eptinezumab-jjmr"],
                "common_misspellings": ["viepti", "eptinezemab", "eptinezumob"]
            },
            
            # Gepants (Acute)
            "nurtec": {
                "generic": "rimegepant",
                "brand": "Nurtec ODT",
                "drug_class": "Gepants",
                "aliases": ["rimegepant", "nurtec", "nurtec odt", "nurtec-odt"],
                "common_misspellings": ["nurtac", "rimegapent", "rimegepent"]
            },
            "ubrelvy": {
                "generic": "ubrogepant",
                "brand": "Ubrelvy",
                "drug_class": "Gepants",
                "aliases": ["ubrogepant", "ubrelvy"],
                "common_misspellings": ["ubrelvey", "ubrogapent", "ubrogepent"]
            },
            
            # Gepants (Preventive)
            "qulipta": {
                "generic": "atogepant",
                "brand": "Qulipta",
                "drug_class": "Gepants (Preventive)",
                "aliases": ["atogepant", "qulipta"],
                "common_misspellings": ["qualipta", "atogapent", "atogepent"]
            },
            
            # Ditans
            "reyvow": {
                "generic": "lasmiditan",
                "brand": "Reyvow",
                "drug_class": "Ditans",
                "aliases": ["lasmiditan", "reyvow"],
                "common_misspellings": ["rayvow", "lasmidatan", "lasmiditant"]
            },
            
            # Botox
            "botox": {
                "generic": "onabotulinumtoxinA",
                "brand": "Botox",
                "drug_class": "Botox",
                "aliases": ["onabotulinumtoxina", "botox", "onabotulinum", "onabotulinumtoxin a"],
                "common_misspellings": ["botulinum", "onabotulinum"]
            },
            
            # Triptans
            "sumatriptan": {
                "generic": "sumatriptan",
                "brand": "Imitrex",
                "drug_class": "Triptan",
                "aliases": ["sumatriptan", "imitrex", "sumavel", "zecuity"],
                "common_misspellings": ["sumatripptan", "sumatriptin", "imitrix"]
            },
            "rizatriptan": {
                "generic": "rizatriptan",
                "brand": "Maxalt",
                "drug_class": "Triptan",
                "aliases": ["rizatriptan", "maxalt", "maxalt-mlt"],
                "common_misspellings": ["rizatripptan", "rizatriptin"]
            },
            "zolmitriptan": {
                "generic": "zolmitriptan",
                "brand": "Zomig",
                "drug_class": "Triptan",
                "aliases": ["zolmitriptan", "zomig", "zomig-zmt"],
                "common_misspellings": ["zolmitripptan", "zolmitriptin"]
            },
            "eletriptan": {
                "generic": "eletriptan",
                "brand": "Relpax",
                "drug_class": "Triptan",
                "aliases": ["eletriptan", "relpax"],
                "common_misspellings": ["eletripptan", "eletriptin"]
            },
            "naratriptan": {
                "generic": "naratriptan",
                "brand": "Amerge",
                "drug_class": "Triptan",
                "aliases": ["naratriptan", "amerge"],
                "common_misspellings": ["naratripptan", "naratriptin"]
            },
            "almotriptan": {
                "generic": "almotriptan",
                "brand": "Axert",
                "drug_class": "Triptan",
                "aliases": ["almotriptan", "axert"],
                "common_misspellings": ["almotripptan", "almotriptin"]
            },
            "frovatriptan": {
                "generic": "frovatriptan",
                "brand": "Frova",
                "drug_class": "Triptan",
                "aliases": ["frovatriptan", "frova"],
                "common_misspellings": ["frovatripptan", "frovatriptin"]
            },
            
            # Oral Preventives - Beta Blockers
            "propranolol": {
                "generic": "propranolol",
                "brand": "Inderal",
                "drug_class": "Beta-blocker",
                "aliases": ["propranolol", "inderal", "inderal la", "innopran xl"],
                "common_misspellings": ["propanolol", "propranolal", "propanalol", "indral"]
            },
            "metoprolol": {
                "generic": "metoprolol",
                "brand": "Toprol-XL",
                "drug_class": "Beta-blocker",
                "aliases": ["metoprolol", "toprol", "toprol-xl", "lopressor"],
                "common_misspellings": ["metropolol", "metaprolol", "topral"]
            },
            "timolol": {
                "generic": "timolol",
                "brand": "Blocadren",
                "drug_class": "Beta-blocker",
                "aliases": ["timolol", "blocadren"],
                "common_misspellings": ["timelol", "timolal"]
            },
            "atenolol": {
                "generic": "atenolol",
                "brand": "Tenormin",
                "drug_class": "Beta-blocker",
                "aliases": ["atenolol", "tenormin"],
                "common_misspellings": ["atenalol", "atenolal"]
            },
            "nadolol": {
                "generic": "nadolol",
                "brand": "Corgard",
                "drug_class": "Beta-blocker",
                "aliases": ["nadolol", "corgard"],
                "common_misspellings": ["nadolal", "corgaard"]
            },
            
            # Anticonvulsants
            "topiramate": {
                "generic": "topiramate",
                "brand": "Topamax",
                "drug_class": "Anticonvulsant",
                "aliases": ["topiramate", "topamax", "trokendi xr", "qudexy xr"],
                "common_misspellings": ["topimax", "topomax", "topiramat", "topirimate"]
            },
            "valproate": {
                "generic": "valproate",
                "brand": "Depakote",
                "drug_class": "Anticonvulsant",
                "aliases": ["valproate", "valproic acid", "divalproex", "depakote", "depakene"],
                "common_misspellings": ["valproat", "divalproax", "depakot"]
            },
            "gabapentin": {
                "generic": "gabapentin",
                "brand": "Neurontin",
                "drug_class": "Anticonvulsant",
                "aliases": ["gabapentin", "neurontin", "gralise"],
                "common_misspellings": ["gabapantin", "neuronten"]
            },
            "zonisamide": {
                "generic": "zonisamide",
                "brand": "Zonegran",
                "drug_class": "Anticonvulsant",
                "aliases": ["zonisamide", "zonegran"],
                "common_misspellings": ["zonisamid", "zonegram"]
            },
            
            # Antidepressants - TCAs
            "amitriptyline": {
                "generic": "amitriptyline",
                "brand": "Elavil",
                "drug_class": "TCA",
                "aliases": ["amitriptyline", "elavil"],
                "common_misspellings": ["amitryptiline", "amitriptiline", "amitriptylene", "elavill"]
            },
            "nortriptyline": {
                "generic": "nortriptyline",
                "brand": "Pamelor",
                "drug_class": "TCA",
                "aliases": ["nortriptyline", "pamelor"],
                "common_misspellings": ["nortryptiline", "nortriptiline", "pamalore"]
            },
            
            # Antidepressants - SNRIs
            "venlafaxine": {
                "generic": "venlafaxine",
                "brand": "Effexor",
                "drug_class": "SNRI",
                "aliases": ["venlafaxine", "effexor", "effexor xr"],
                "common_misspellings": ["venlafaxene", "venlafaxin", "effexer"]
            },
            "duloxetine": {
                "generic": "duloxetine",
                "brand": "Cymbalta",
                "drug_class": "SNRI",
                "aliases": ["duloxetine", "cymbalta"],
                "common_misspellings": ["duloxatine", "duloxetin", "cymbalta"]
            },
            
            # Calcium Channel Blockers
            "verapamil": {
                "generic": "verapamil",
                "brand": "Calan",
                "drug_class": "CCB",
                "aliases": ["verapamil", "calan", "verelan", "isoptin"],
                "common_misspellings": ["verapamyl", "verapamol", "calin"]
            },
            "flunarizine": {
                "generic": "flunarizine",
                "brand": "Sibelium",
                "drug_class": "CCB",
                "aliases": ["flunarizine", "sibelium"],
                "common_misspellings": ["flunarizin", "flunarazine"]
            },
            
            # Other
            "lithium": {
                "generic": "lithium",
                "brand": "Lithobid",
                "drug_class": "Mood Stabilizer",
                "aliases": ["lithium", "lithobid", "lithium carbonate"],
                "common_misspellings": ["litheum", "lithiam"]
            },
            "candesartan": {
                "generic": "candesartan",
                "brand": "Atacand",
                "drug_class": "ARB",
                "aliases": ["candesartan", "atacand"],
                "common_misspellings": ["candesarten", "candesartin", "atacond"]
            },
            "lisinopril": {
                "generic": "lisinopril",
                "brand": "Zestril",
                "drug_class": "ACE Inhibitor",
                "aliases": ["lisinopril", "zestril", "prinivil"],
                "common_misspellings": ["lisinopral", "lisinipril", "zestrel"]
            },
            "memantine": {
                "generic": "memantine",
                "brand": "Namenda",
                "drug_class": "NMDA Antagonist",
                "aliases": ["memantine", "namenda"],
                "common_misspellings": ["memantene", "memantin", "namenda"]
            },
            "magnesium": {
                "generic": "magnesium",
                "brand": "Magnesium",
                "drug_class": "Supplement",
                "aliases": ["magnesium", "magnesium oxide", "magnesium citrate", "mag oxide"],
                "common_misspellings": ["magnisium", "magneseum"]
            },
            "riboflavin": {
                "generic": "riboflavin",
                "brand": "Vitamin B2",
                "drug_class": "Supplement",
                "aliases": ["riboflavin", "vitamin b2", "b2"],
                "common_misspellings": ["riboflavine", "riboflabin"]
            },
            "coq10": {
                "generic": "coenzyme q10",
                "brand": "CoQ10",
                "drug_class": "Supplement",
                "aliases": ["coenzyme q10", "coq10", "ubiquinone"],
                "common_misspellings": ["coq-10", "co-q10"]
            },
        }
        
        # Build lookup indices
        self.alias_to_key = {}
        self.generic_to_key = {}
        self.brand_to_key = {}
        
        for key, med_data in self.medication_db.items():
            self.generic_to_key[med_data["generic"].lower()] = key
            self.brand_to_key[med_data["brand"].lower()] = key
            for alias in med_data["aliases"]:
                self.alias_to_key[alias.lower()] = key
                
    def normalize_input(self, text: str) -> str:
        """Normalize medication name input"""
        import re
        text = text.lower()
        # Remove dosage information
        text = re.sub(r'\d+\.?\d*\s*(mg|mcg|ml|g|units?)\b.*$', '', text, flags=re.IGNORECASE)
        # Remove common suffixes
        text = re.sub(r'\s+(tablets?|capsules?|injection|subcutaneous|oral|daily|bid|tid|qd|prn)\b.*$', '', text, flags=re.IGNORECASE)
        # Remove parenthetical content
        text = re.sub(r'\([^)]*\)', '', text)
        # Clean up whitespace and hyphens
        text = text.replace('-', ' ')
        text = ' '.join(text.split())
        return text.strip()
        
    def fuzzy_match(self, input_text: str, candidate: str, threshold: float = 0.85) -> float:
        """Calculate similarity ratio between input and candidate"""
        return self.SequenceMatcher(None, input_text.lower(), candidate.lower()).ratio()
        
    def find_medication(self, input_text: str, threshold: float = 0.80) -> Optional[dict]:
        """
        Find medication using multi-strategy matching
        Returns dict with medication data or None
        """
        normalized = self.normalize_input(input_text)
        
        # Strategy 1: Exact match
        if normalized in self.alias_to_key:
            key = self.alias_to_key[normalized]
            return self._build_result(key, 1.0, "exact_alias")
            
        if normalized in self.generic_to_key:
            key = self.generic_to_key[normalized]
            return self._build_result(key, 1.0, "exact_generic")
            
        if normalized in self.brand_to_key:
            key = self.brand_to_key[normalized]
            return self._build_result(key, 1.0, "exact_brand")
        
        # Strategy 2: Fuzzy match against aliases
        best_match = None
        best_score = 0.0
        
        for alias, key in self.alias_to_key.items():
            score = self.fuzzy_match(normalized, alias)
            if score > best_score and score >= threshold:
                best_score = score
                best_match = key
                
        if best_match:
            return self._build_result(best_match, best_score, "fuzzy_alias")
            
        # Strategy 3: Fuzzy match against common misspellings
        for key, med_data in self.medication_db.items():
            for misspelling in med_data.get("common_misspellings", []):
                score = self.fuzzy_match(normalized, misspelling)
                if score > best_score and score >= threshold:
                    best_score = score
                    best_match = key
                    
        if best_match:
            return self._build_result(best_match, best_score, "fuzzy_misspelling")
            
        # Strategy 4: Fuzzy match against all medication keys
        for key in self.medication_db.keys():
            score = self.fuzzy_match(normalized, key)
            if score > best_score and score >= threshold:
                best_score = score
                best_match = key
                
        if best_match:
            return self._build_result(best_match, best_score, "fuzzy_key")
            
        return None
        
    def _build_result(self, key: str, confidence: float, match_type: str) -> dict:
        """Build result dictionary with medication data"""
        med_data = self.medication_db[key]
        return {
            "key": key,
            "generic": med_data["generic"],
            "brand": med_data["brand"],
            "drug_class": med_data["drug_class"],
            "confidence": confidence,
            "match_type": match_type,
            "all_aliases": med_data["aliases"]
        }
        
    def get_drug_class(self, medication_name: str) -> Optional[str]:
        """Get drug class for a medication name"""
        result = self.find_medication(medication_name)
        return result["drug_class"] if result else None
        
    def search_multiple(self, medication_list: List[str], threshold: float = 0.80) -> List[dict]:
        """Search for multiple medications and return results"""
        results = []
        for med in medication_list:
            match = self.find_medication(med, threshold)
            if match:
                match["original_input"] = med  # Keep track of original input
                results.append(match)
        return results


# Initialize global medication matcher
medication_matcher = MedicationMatcher()


# ============================================================================
# GUIDED DATA COLLECTION SYSTEM
# ============================================================================

class FieldPriority(Enum):
    """Priority levels for data collection fields."""
    REQUIRED = "required"      # Must have before search (state)
    IMPORTANT = "important"    # Strongly recommended (payer, drug)
    HELPFUL = "helpful"        # Nice to have (diagnosis, age)

@dataclass
class DataCollectionState:
    """Tracks what data has been collected and what's missing."""
    state: Optional[str] = None
    payer: Optional[str] = None
    drug_class: Optional[str] = None
    diagnosis: Optional[str] = None
    age: Optional[str] = None
    prior_medications: List[str] = field(default_factory=list)
    
    def get_collected_fields(self) -> List[str]:
        collected = []
        if self.state: collected.append('state')
        if self.payer: collected.append('payer')
        if self.drug_class: collected.append('drug_class')
        if self.diagnosis: collected.append('diagnosis')
        if self.age: collected.append('age')
        if self.prior_medications: collected.append('prior_medications')
        return collected
    
    def get_missing_required_fields(self) -> List[str]:
        missing = []
        if not self.state: missing.append('state')
        return missing
    
    def can_proceed_to_search(self) -> bool:
        return self.state is not None
    
    def get_search_quality_score(self) -> Tuple[int, str]:
        score = 0
        if self.state: score += 40
        if self.payer: score += 30
        if self.drug_class: score += 20
        if self.diagnosis: score += 4
        if self.age: score += 3
        if self.prior_medications: score += 3
        
        if score >= 90:
            return score, "Excellent - Highly targeted search"
        elif score >= 70:
            return score, "Good - Well-targeted search"
        elif score >= 50:
            return score, "Fair - Broad search, may have many results"
        elif score >= 40:
            return score, "Limited - State-level search only"
        else:
            return score, "Insufficient - State required"

# ============================================================================
# MEDICATION TRIAL TRACKING & GAP ANALYSIS
# ============================================================================

@dataclass
class MedicationTrial:
    """Tracks details of a single medication trial for step therapy documentation."""
    medication_name: str
    drug_class: Optional[str] = None  # Beta-blocker, Anticonvulsant, etc.
    dose: Optional[str] = None  # e.g., "100mg/day"
    duration_weeks: Optional[int] = None  # Duration in weeks
    reason_stopped: Optional[str] = None  # Ineffective, Side effects, etc.
    details_complete: bool = False
    
    # Reference data (from Therapeutic_Doses.csv)
    therapeutic_dose_min: Optional[int] = None
    therapeutic_dose_max: Optional[int] = None
    recommended_duration_weeks: Optional[int] = None
    
    def calculate_completeness(self) -> Tuple[int, List[str]]:
        """Returns (percent_complete, list_of_missing_fields)"""
        required_fields = ['dose', 'duration_weeks', 'reason_stopped']
        missing = []
        
        if not self.dose:
            missing.append('dose')
        if not self.duration_weeks:
            missing.append('duration')
        if not self.reason_stopped:
            missing.append('reason stopped')
        
        complete = len(required_fields) - len(missing)
        percent = int((complete / len(required_fields)) * 100)
        return percent, missing
    
    def is_adequate_trial(self) -> Tuple[bool, str]:
        """Check if trial meets therapeutic standards."""
        if not self.dose or not self.duration_weeks:
            return False, "Missing dose or duration"
        
        # Check duration (most require 8 weeks)
        min_weeks = self.recommended_duration_weeks or 8
        if self.duration_weeks < min_weeks:
            return False, f"Trial too short ({self.duration_weeks} weeks vs {min_weeks} required)"
        
        return True, "Adequate trial documented"

@dataclass 
class GapAnalysis:
    """Analyzes gaps between extracted data and PA requirements."""
    policy_requirements: dict  # From payer policy row
    extracted_medications: List[MedicationTrial]
    diagnosis: Optional[str] = None
    headache_days: Optional[int] = None
    
    # Calculated fields
    required_med_classes: int = 2
    classes_documented: int = 0
    classes_with_complete_details: int = 0
    missing_details: List[dict] = field(default_factory=list)
    
    def analyze(self) -> dict:
        """Perform gap analysis and return structured results."""
        results = {
            'ready_for_pa': False,
            'medication_gaps': [],
            'documentation_gaps': [],
            'recommendations': [],
            'completeness_score': 0
        }
        
        # Determine how many medication classes are required
        step_req = self.policy_requirements.get('Step_1_Requirement', '').lower()
        if '2 oral preventive' in step_req or '‚â•2' in step_req:
            self.required_med_classes = 2
        elif '1 oral preventive' in step_req or '‚â•1' in step_req:
            self.required_med_classes = 1
        elif 'triptan' in step_req:
            self.required_med_classes = 1 if '1' in step_req else 2
        
        # Count documented classes
        classes_found = set()
        for med in self.extracted_medications:
            if med.drug_class:
                classes_found.add(med.drug_class)
                completeness, missing = med.calculate_completeness()
                
                if missing:
                    results['medication_gaps'].append({
                        'medication': med.medication_name,
                        'class': med.drug_class,
                        'missing': missing,
                        'completeness': completeness
                    })
                else:
                    self.classes_with_complete_details += 1
        
        self.classes_documented = len(classes_found)
        
        # Check if we have enough classes
        if self.classes_documented < self.required_med_classes:
            results['documentation_gaps'].append(
                f"Need {self.required_med_classes} medication classes, only {self.classes_documented} documented"
            )
            results['recommendations'].append(
                f"Document {self.required_med_classes - self.classes_documented} more failed medication(s)"
            )
        
        # Check completeness of documented medications
        if results['medication_gaps']:
            results['recommendations'].append(
                "Complete missing details (dose, duration, reason stopped) for documented medications"
            )
        
        # Calculate overall completeness
        if self.required_med_classes > 0:
            class_score = min(100, (self.classes_documented / self.required_med_classes) * 50)
            detail_score = (self.classes_with_complete_details / max(1, self.classes_documented)) * 50
            results['completeness_score'] = int(class_score + detail_score)
        
        # Determine if ready for PA
        results['ready_for_pa'] = (
            self.classes_documented >= self.required_med_classes and
            len(results['medication_gaps']) == 0
        )
        
        return results


# Therapeutic dose reference data (from Therapeutic_Doses.csv)
THERAPEUTIC_DOSES = {
    'propranolol': {'class': 'Beta-blocker', 'min_dose': 80, 'max_dose': 240, 'unit': 'mg/day', 'min_weeks': 8},
    'metoprolol': {'class': 'Beta-blocker', 'min_dose': 100, 'max_dose': 200, 'unit': 'mg/day', 'min_weeks': 8},
    'atenolol': {'class': 'Beta-blocker', 'min_dose': 50, 'max_dose': 200, 'unit': 'mg/day', 'min_weeks': 8},
    'topiramate': {'class': 'Anticonvulsant', 'min_dose': 100, 'max_dose': 200, 'unit': 'mg/day', 'min_weeks': 8},
    'valproate': {'class': 'Anticonvulsant', 'min_dose': 500, 'max_dose': 1500, 'unit': 'mg/day', 'min_weeks': 8},
    'divalproex': {'class': 'Anticonvulsant', 'min_dose': 500, 'max_dose': 1500, 'unit': 'mg/day', 'min_weeks': 8},
    'gabapentin': {'class': 'Anticonvulsant', 'min_dose': 1200, 'max_dose': 2400, 'unit': 'mg/day', 'min_weeks': 8},
    'amitriptyline': {'class': 'Antidepressant', 'min_dose': 50, 'max_dose': 150, 'unit': 'mg/day', 'min_weeks': 8},
    'nortriptyline': {'class': 'Antidepressant', 'min_dose': 50, 'max_dose': 150, 'unit': 'mg/day', 'min_weeks': 8},
    'venlafaxine': {'class': 'Antidepressant', 'min_dose': 150, 'max_dose': 225, 'unit': 'mg/day', 'min_weeks': 8},
    'duloxetine': {'class': 'Antidepressant', 'min_dose': 60, 'max_dose': 120, 'unit': 'mg/day', 'min_weeks': 8},
    'verapamil': {'class': 'CCB', 'min_dose': 240, 'max_dose': 960, 'unit': 'mg/day', 'min_weeks': 4},
    'sumatriptan': {'class': 'Triptan', 'min_dose': 50, 'max_dose': 100, 'unit': 'mg/dose', 'min_weeks': 4},
    'rizatriptan': {'class': 'Triptan', 'min_dose': 5, 'max_dose': 10, 'unit': 'mg/dose', 'min_weeks': 4},
    'eletriptan': {'class': 'Triptan', 'min_dose': 20, 'max_dose': 40, 'unit': 'mg/dose', 'min_weeks': 4},
    'zolmitriptan': {'class': 'Triptan', 'min_dose': 2.5, 'max_dose': 5, 'unit': 'mg/dose', 'min_weeks': 4},
}

DISCONTINUATION_REASONS = [
    "Ineffective - less than 50% reduction",
    "Ineffective - no improvement",
    "Side effects - intolerable",
    "Side effects - cognitive",
    "Side effects - weight changes", 
    "Side effects - fatigue",
    "Side effects - GI issues",
    "Contraindicated",
    "Patient preference",
    "Cost/access issues",
    "Other"
]

def create_medication_trials_from_parsed(prior_medications) -> List[MedicationTrial]:
    """Convert parsed medication data into MedicationTrial objects with reference data.
    
    Handles both old format (list of strings) and new format (list of dicts with dose/duration/reason).
    Uses MedicationMatcher for robust name matching, then cross-references with
    THERAPEUTIC_DOSES for dosing thresholds.
    """
    trials = []
    
    for med_data in prior_medications:
        # Handle both old format (string) and new format (dict)
        if isinstance(med_data, str):
            med_name = med_data
            parsed_dose = None
            parsed_duration = None
            parsed_reason = None
        elif isinstance(med_data, dict):
            med_name = med_data.get('name', '')
            parsed_dose = med_data.get('dose')
            parsed_duration = med_data.get('duration_weeks')
            parsed_reason = med_data.get('reason_stopped')
        else:
            continue
        
        if not med_name:
            continue
            
        med_lower = med_name.lower().strip()
        
        # First, try MedicationMatcher for robust name recognition
        med_match = medication_matcher.find_medication(med_name, threshold=0.80)
        
        # Find matching therapeutic reference (for dosing info)
        matched_ref = None
        search_key = med_match['generic'] if med_match else med_lower
        for ref_name, ref_data in THERAPEUTIC_DOSES.items():
            if ref_name in search_key.lower() or search_key.lower() in ref_name:
                matched_ref = (ref_name, ref_data)
                break
        
        # Use MedicationMatcher drug_class if available, otherwise fall back to THERAPEUTIC_DOSES
        drug_class = None
        if med_match:
            drug_class = med_match['drug_class']
        elif matched_ref:
            drug_class = matched_ref[1]['class']
        
        # Use brand name from matcher if available for cleaner display
        display_name = med_match['brand'] if med_match else med_name.title()
        
        # Convert duration to int if it's a valid number
        duration_weeks = None
        if parsed_duration is not None:
            try:
                duration_weeks = int(parsed_duration)
            except (ValueError, TypeError):
                pass
        
        trial = MedicationTrial(
            medication_name=display_name,
            drug_class=drug_class,
            dose=parsed_dose,
            duration_weeks=duration_weeks,
            reason_stopped=parsed_reason,
            therapeutic_dose_min=matched_ref[1]['min_dose'] if matched_ref else None,
            therapeutic_dose_max=matched_ref[1]['max_dose'] if matched_ref else None,
            recommended_duration_weeks=matched_ref[1]['min_weeks'] if matched_ref else 8
        )
        trials.append(trial)
    
    return trials

# Page configuration
st.set_page_config(
    page_title="The Headache Vault - PA Automation Demo",
    page_icon="üíä",  # Medical/pill icon instead of brain
    layout="wide",
    initial_sidebar_state="expanded"
)

# Force light theme
st.markdown("""
<script>
    window.parent.document.documentElement.setAttribute('data-theme', 'light');
</script>
""", unsafe_allow_html=True)

# Custom CSS with Headache Vault brand identity
st.markdown("""
<style>
    /* Import brand fonts */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Source+Sans+Pro:wght@400;600&display=swap');
    
    /* Force light theme and readable backgrounds */
    .stApp {
        background-color: #FFFFFF !important;
    }
    
    .main .block-container {
        background-color: #FFFFFF !important;
    }
    
    /* Global font override */
    html, body, [class*="css"] {
        font-family: 'Source Sans Pro', sans-serif;
        color: #262730 !important;
    }
    
    h1, h2, h3, h4, h5, h6 {
        font-family: 'Inter', sans-serif;
        font-weight: 700;
        color: #262730 !important;
    }
    
    .main-header {
        font-size: 2.5rem;
        color: #4B0082;  /* Regulatory Purple */
        font-weight: 700;
        margin-bottom: 0.5rem;
        font-family: 'Inter', sans-serif;
    }
    .sub-header {
        font-size: 1.2rem;
        color: #5A5A5A;  /* Readable gray */
        margin-bottom: 2rem;
        font-family: 'Source Sans Pro', sans-serif;
    }
    .step-box {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #4B0082;  /* Regulatory Purple */
        margin: 1rem 0;
        color: #262730;
    }
    .warning-box {
        background-color: #FFF9E6;  /* Lighter yellow for warnings */
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #FFD700;  /* Gold Card Yellow */
        margin: 1rem 0;
        color: #856404;
    }
    .success-box {
        background-color: #F5F0FF;  /* Lavender tint */
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid #FFD700;  /* Gold Card Yellow for Gold Card status */
        margin: 1rem 0;
        color: #262730;  /* Dark text for readability */
    }
    .evidence-tag {
        display: inline-block;
        background-color: #E6E6FA;  /* Compassion Lavender */
        padding: 0.25rem 0.75rem;
        border-radius: 12px;
        font-size: 0.85rem;
        margin: 0.25rem;
        color: #262730;  /* Dark text for readability */
        font-weight: 600;
    }
    
    /* Update primary button colors */
    .stButton > button[kind="primary"] {
        background-color: #4B0082 !important;  /* Regulatory Purple */
        color: white !important;
    }
    
    .stButton > button[kind="primary"]:hover {
        background-color: #6A0DAD !important;  /* Lighter purple on hover */
    }
    
    /* Secondary buttons */
    .stButton > button[kind="secondary"] {
        background-color: #FFFFFF !important;
        color: #4B0082 !important;
        border: 2px solid #4B0082 !important;
    }
    
    .stButton > button[kind="secondary"]:hover {
        background-color: #F5F0FF !important;  /* Light purple tint on hover */
        color: #4B0082 !important;
    }
    
    /* Regular buttons */
    .stButton > button {
        color: #262730 !important;  /* Dark text for visibility */
    }
    
    /* Production Features - Dashboard Stats */
    .stat-card {
        background: linear-gradient(135deg, #4B0082 0%, #6A0DAD 100%);
        padding: 1.5rem;
        border-radius: 12px;
        color: white;
        text-align: center;
        box-shadow: 0 4px 6px rgba(75, 0, 130, 0.3);
    }
    .stat-number {
        font-size: 2.75rem;
        font-weight: 800;
        font-family: 'Inter', sans-serif;
        margin: 0;
        color: white !important;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    .stat-label {
        font-size: 1rem;
        font-weight: 600;
        margin-top: 0.5rem;
        color: white !important;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }
    
    /* Policy Result Cards */
    .policy-card {
        background: white;
        border: 2px solid #E6E6FA;
        border-radius: 12px;
        padding: 1.5rem;
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        transition: all 0.3s ease;
    }
    .policy-card:hover {
        border-color: #4B0082;
        box-shadow: 0 4px 12px rgba(75, 0, 130, 0.15);
    }
    .policy-header {
        display: flex;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid #F0F0F0;
    }
    .policy-title {
        font-size: 1.3rem;
        font-weight: 700;
        color: #4B0082;
        margin: 0;
    }
    .policy-badge {
        display: inline-block;
        background: #E6E6FA;
        padding: 0.25rem 0.75rem;
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 600;
        color: #4B0082;
        margin-left: 0.5rem;
    }
    .policy-section {
        margin: 1rem 0;
    }
    .policy-section-title {
        font-size: 0.9rem;
        font-weight: 600;
        color: #708090;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 0.5rem;
    }
    .step-item {
        display: flex;
        align-items: flex-start;
        padding: 0.75rem;
        background: #FAFAFA;
        border-radius: 8px;
        margin: 0.5rem 0;
        color: #262730;  /* Ensure dark text on light background */
    }
    .step-item strong {
        color: #262730;  /* Dark text for medication names */
    }
    .step-item small {
        color: #708090;  /* Slate gray for durations */
    }
    .step-number {
        background: #4B0082;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        font-size: 0.85rem;
        margin-right: 0.75rem;
        flex-shrink: 0;
    }
    .gold-card-badge {
        background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
        color: #000;  /* Black text on gold - high contrast */
        padding: 0.5rem 1rem;
        border-radius: 8px;
        font-weight: 700;
        display: inline-block;
        margin: 0.5rem 0;
    }
    
    /* Copy Button Styling */
    .copy-button {
        background: #4B0082;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        transition: all 0.2s ease;
    }
    .copy-button:hover {
        background: #6A0DAD;
        transform: translateY(-1px);
    }
    
    /* Success Toast */
    .success-toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #10B981;
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 9999;
        animation: slideIn 0.3s ease;
    }
    @keyframes slideIn {
        from { transform: translateX(400px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    
    /* Production Footer */
    .production-footer {
        margin-top: 3rem;
        padding: 2rem 0;
        border-top: 2px solid #E6E6FA;
        text-align: center;
        color: #708090;
    }
    .footer-badge {
        display: inline-block;
        margin: 0 0.5rem;
        font-size: 0.85rem;
        color: #4B0082;
    }
    
    /* Dashboard Quick Actions */
    .quick-action-btn {
        background: white;
        border: 2px solid #4B0082;
        padding: 1.5rem;
        border-radius: 12px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        color: #4B0082;
        font-weight: 600;
    }
    .quick-action-btn:hover {
        background: #4B0082;
        color: white;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(75, 0, 130, 0.2);
    }
    
    /* Sidebar styling */
    section[data-testid="stSidebar"] {
        background-color: #FAFAFA !important;  /* Light gray */
    }
    
    /* Fix sidebar form elements - dropdowns, radio buttons, etc. */
    section[data-testid="stSidebar"] .stSelectbox > div > div {
        background-color: #FFFFFF !important;  /* White background for dropdowns */
        color: #262730 !important;  /* Dark text */
    }
    
    section[data-testid="stSidebar"] input {
        background-color: #FFFFFF !important;
        color: #262730 !important;
    }
    
    section[data-testid="stSidebar"] [data-baseweb="select"] {
        background-color: #FFFFFF !important;
    }
    
    section[data-testid="stSidebar"] [data-baseweb="select"] > div {
        background-color: #FFFFFF !important;
        color: #262730 !important;
    }
    
    /* Dropdown menu items */
    [data-baseweb="popover"] {
        background-color: #FFFFFF !important;
    }
    
    [role="option"] {
        background-color: #FFFFFF !important;
        color: #262730 !important;
    }
    
    [role="option"]:hover {
        background-color: #F0F0F0 !important;
    }
    
    /* Radio buttons */
    section[data-testid="stSidebar"] [data-testid="stRadio"] label {
        color: #262730 !important;
    }
    
    section[data-testid="stSidebar"] [data-testid="stRadio"] > div {
        color: #262730 !important;
    }
    
    /* Number input */
    section[data-testid="stSidebar"] input[type="number"] {
        background-color: #FFFFFF !important;
        color: #262730 !important;
    }
    
    /* All sidebar labels */
    section[data-testid="stSidebar"] label {
        color: #262730 !important;
        font-weight: 600 !important;
    }
    
    /* Sidebar header */
    section[data-testid="stSidebar"] h2 {
        color: #262730 !important;
    }
    
    /* Metrics styling */
    [data-testid="stMetricValue"] {
        color: #262730;  /* Dark readable text for metric values */
        font-weight: 700;
    }
    
    [data-testid="stMetricLabel"] {
        color: #5A5A5A;  /* Gray for metric labels */
    }
    
    /* Tab styling */
    .stTabs [data-baseweb="tab-list"] {
        gap: 8px;
    }
    
    .stTabs [data-baseweb="tab"] {
        font-family: 'Inter', sans-serif;
        font-weight: 600;
        color: #5A5A5A;  /* Readable gray for inactive tabs */
        background-color: transparent !important;
    }
    
    .stTabs [aria-selected="true"] {
        color: #262730 !important;  /* Dark text for active tab */
        border-bottom-color: #4B0082 !important;  /* Purple underline for active */
        background-color: transparent !important;
    }
    
    /* General form elements in main area */
    .stSelectbox > div > div,
    .stTextInput > div > div,
    .stTextArea > div > div {
        background-color: #FFFFFF !important;
        color: #262730 !important;
    }
    
    input, textarea, select {
        background-color: #FFFFFF !important;
        color: #262730 !important;
    }
    
    /* Expander styling */
    .streamlit-expanderHeader {
        background-color: #F8F9FA !important;
        color: #262730 !important;
    }
    
    /* Info boxes, warnings, etc */
    .stAlert {
        background-color: #F8F9FA !important;
    }
    
    /* Ensure text in info/success/warning/error boxes is visible */
    .stAlert [data-testid="stMarkdownContainer"] {
        color: #262730 !important;
    }
    
    .stAlert strong {
        color: #262730 !important;
    }
    
    /* Toast notification styling - fix visibility */
    [data-testid="stToast"], 
    .stToast,
    div[data-baseweb="toast"] {
        background-color: #10B981 !important;
        color: white !important;
    }
    
    [data-testid="stToast"] *,
    .stToast *,
    div[data-baseweb="toast"] * {
        color: white !important;
    }
    
    /* Toast container */
    [data-testid="toastContainer"] {
        z-index: 9999 !important;
    }
    
    /* Caption text visibility */
    .stCaption {
        color: #708090 !important;  /* Slate gray - readable on white */
    }
    
    /* ===================================================================== */
    /* NUCLEAR OPTION - FORCE ALL TEXT VISIBLE */
    /* ===================================================================== */
    
    /* Force all text elements to be dark EXCEPT primary buttons and stat cards */
    p:not(.stButton [kind="primary"] *):not(.stat-card *):not(.stat-number):not(.stat-label), 
    span:not(.stButton [kind="primary"] *):not(.stat-card *):not(.stat-number):not(.stat-label), 
    div:not(.stButton [kind="primary"] *):not(.stat-card):not(.stat-number):not(.stat-label), 
    label, li, td, th, h1, h2, h3, h4, h5, h6 {
        color: #262730 !important;
    }
    
    /* PRIMARY BUTTONS - Keep white text */
    .stButton > button[kind="primary"],
    .stButton > button[kind="primary"] *,
    button[kind="primary"] span,
    button[kind="primary"] div,
    button[kind="primary"] p {
        color: white !important;
    }
    
    /* Except for elements with specific styling */
    /* STAT CARDS - Force white/lavender text on purple background */
    .stat-card,
    .stat-card *,
    .stat-card div,
    .stat-card span,
    .stat-card .stat-number,
    .stat-card .stat-number span,
    .stat-card .stat-label,
    .stat-card .stat-label span,
    div.stat-card div.stat-number,
    div.stat-card div.stat-number span,
    div.stat-card div.stat-label,
    div.stat-card div.stat-label span {
        color: white !important;
    }
    .stat-number,
    .stat-number span {
        color: #FFFFFF !important;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.4) !important;
    }
    .stat-label,
    .stat-label span {
        color: #E6E6FA !important;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.3) !important;
    }
    
    /* Other exceptions */
    .step-number * {
        color: white !important;
    }
    
    /* Force selectbox and dropdown text */
    [data-baseweb="select"] span,
    [data-baseweb="select"] div,
    [role="listbox"] *,
    [role="option"] * {
        color: #262730 !important;
    }
    
    /* Force all button text except primary purple buttons */
    button:not([kind="primary"]) * {
        color: #4B0082 !important;
    }
    
    /* Force dataframe text */
    .dataframe, .dataframe *, table, table * {
        color: #262730 !important;
        background-color: #FFFFFF !important;
    }
    
    /* Force markdown container text */
    [data-testid="stMarkdownContainer"],
    [data-testid="stMarkdownContainer"] *,
    [data-testid="stMarkdownContainer"] p,
    [data-testid="stMarkdownContainer"] span,
    [data-testid="stMarkdownContainer"] div {
        color: #262730 !important;
    }
    
    /* Force all text areas and inputs */
    textarea, input, select {
        color: #262730 !important;
        background-color: #FFFFFF !important;
    }
    
    /* Force code blocks */
    code, pre, .stCode {
        color: #262730 !important;
        background-color: #F8F9FA !important;
    }
    
    /* ===================================================================== */
    /* PERSONA TOGGLE & GUIDANCE STYLES */
    /* ===================================================================== */
    
    /* Experience Mode Toggle */
    .mode-toggle {
        background: linear-gradient(135deg, #F8F9FA 0%, #FFFFFF 100%);
        border: 2px solid #E6E6FA;
        border-radius: 12px;
        padding: 0.75rem 1.5rem;
        margin: 1rem 0;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
    }
    
    .mode-label {
        font-size: 0.9rem;
        color: #5A5A5A;
        font-weight: 500;
    }
    
    /* Learning Moment Box */
    .learning-moment {
        background: linear-gradient(135deg, #FFF9E6 0%, #FFFEF5 100%);
        border: 1px solid #FFD700;
        border-left: 4px solid #FFD700;
        border-radius: 8px;
        padding: 1rem 1.25rem;
        margin: 1rem 0;
    }
    
    .learning-moment-title {
        color: #B8860B;
        font-weight: 700;
        font-size: 0.95rem;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .learning-moment-content {
        color: #5A5A5A;
        font-size: 0.9rem;
        line-height: 1.6;
    }
    
    .learning-moment-content ul {
        margin: 0.5rem 0;
        padding-left: 1.25rem;
    }
    
    .learning-moment-content li {
        margin: 0.25rem 0;
        color: #5A5A5A !important;
    }
    
    /* PCP Guidance Expander */
    .pcp-guidance {
        background: #F0F8FF;
        border: 1px solid #B0D4F1;
        border-left: 4px solid #4A90D9;
        border-radius: 8px;
        padding: 1rem 1.25rem;
        margin: 0.75rem 0;
    }
    
    .pcp-guidance-title {
        color: #2C5282;
        font-weight: 600;
        font-size: 0.9rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .pcp-guidance-content {
        color: #4A5568;
        font-size: 0.85rem;
        line-height: 1.6;
        margin-top: 0.75rem;
        padding-top: 0.75rem;
        border-top: 1px solid #B0D4F1;
    }
    
    /* Documentation Checklist */
    .doc-checklist {
        background: #F0FFF4;
        border: 1px solid #9AE6B4;
        border-radius: 8px;
        padding: 1rem;
        margin: 0.75rem 0;
    }
    
    .doc-checklist-title {
        color: #276749;
        font-weight: 600;
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
    }
    
    .doc-checklist-item {
        color: #2F855A;
        font-size: 0.85rem;
        padding: 0.25rem 0;
        display: flex;
        align-items: flex-start;
        gap: 0.5rem;
    }
    
    /* Pitfall Warning */
    .pitfall-warning {
        background: #FFF5F5;
        border: 1px solid #FEB2B2;
        border-left: 4px solid #E53E3E;
        border-radius: 8px;
        padding: 1rem 1.25rem;
        margin: 0.75rem 0;
    }
    
    .pitfall-warning-title {
        color: #C53030;
        font-weight: 700;
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
    }
    
    .pitfall-warning-content {
        color: #742A2A;
        font-size: 0.85rem;
        line-height: 1.5;
    }
    
    /* Pro Tip Box */
    .pro-tip {
        background: linear-gradient(135deg, #EBF8FF 0%, #F0FFFF 100%);
        border: 1px solid #90CDF4;
        border-left: 4px solid #4299E1;
        border-radius: 8px;
        padding: 1rem 1.25rem;
        margin: 0.75rem 0;
    }
    
    .pro-tip-title {
        color: #2B6CB0;
        font-weight: 700;
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
    }
    
    .pro-tip-content {
        color: #2C5282;
        font-size: 0.85rem;
        line-height: 1.5;
    }
    
    /* ===================================================================== */
    /* FINAL STAT CARD OVERRIDE - Highest cascade priority */
    /* ===================================================================== */
    .stat-card .stat-number span,
    div.stat-card div.stat-number span {
        color: #FFFFFF !important;
        text-shadow: 1px 1px 3px rgba(0,0,0,0.4) !important;
    }
    .stat-card .stat-label span,
    div.stat-card div.stat-label span {
        color: #E6E6FA !important;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.3) !important;
    }
/* Quality indicators for guided data collection */
.quality-excellent {
    background: linear-gradient(135deg, #D1FAE5 0%, #A7F3D0 100%);
    color: #065F46;
    border: 1px solid #10B981;
}
.quality-good {
    background: linear-gradient(135deg, #DBEAFE 0%, #BFDBFE 100%);
    color: #1E40AF;
    border: 1px solid #3B82F6;
}
.quality-fair {
    background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%);
    color: #92400E;
    border: 1px solid #F59E0B;
}
.quality-limited {
    background: linear-gradient(135deg, #FEE2E2 0%, #FECACA 100%);
    color: #991B1B;
    border: 1px solid #EF4444;
}
.required-field-box {
    background: #FEF2F2;
    border: 2px solid #DC2626;
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
}
</style>
""", unsafe_allow_html=True)

# Load databases
@st.cache_data
def load_databases():
    """
    Load all Headache Vault databases from CSV files.
    
    Database Schema (v3.0 ‚Äî 8,852 records):
    - payer_registry: 1,154 payers with LOB codes, Vault_Payer_ID format
    - payer_policies: 915 policies with step therapy, drug class taxonomy
    - formulary_tier_map: 6,549 drug-level formulary status by payer
    - denial_codes: 42 denial scenarios with appeal strategies
    - pediatric_overrides: 24 records with safety flags (valproate, topiramate)
    - state_regulations: 51 states with Gold Card legislation details
    - icd10_codes: 47 diagnosis codes with ICHD-3 mappings
    - therapeutic_doses: 41 medications with ACP 2025 thresholds
    - otc_medications: 29 OTC meds for MOH tracking
    """
    payer_registry = pd.read_csv('Payer_Registry.csv')
    payer_policies = pd.read_csv('Payer_Policies.csv')
    denial_codes = pd.read_csv('Denial_Codes_Appeals.csv')
    pediatric_overrides = pd.read_csv('Pediatric_Overrides.csv')
    state_regulations = pd.read_csv('State_Regulations.csv')
    icd10_codes = pd.read_csv('ICD10_Diagnosis_Codes.csv')
    therapeutic_doses = pd.read_csv('Therapeutic_Doses.csv')
    otc_medications = pd.read_csv('OTC_Medications.csv')
    
    # Formulary Tier Map ‚Äî drug-level coverage details per payer (v3.0)
    try:
        formulary_tier_map = pd.read_csv('Formulary_Tier_Map.csv')
    except FileNotFoundError:
        formulary_tier_map = pd.DataFrame(columns=[
            'Vault_Payer_ID', 'State', 'Payer_Name', 'Drug_Name', 'Drug_Class',
            'Formulary_Status', 'Tier', 'Quantity_Limit', 'Step_Within_Class',
            'Site_of_Care', 'PBM_Partner', 'Year', 'Confidence', 'Source', 'Notes'
        ])
    
    return payer_registry, payer_policies, formulary_tier_map, denial_codes, pediatric_overrides, state_regulations, icd10_codes, therapeutic_doses, otc_medications

# ============================================================================
# HELPER: Get step therapy details with column name fallback
# ============================================================================
def get_step_therapy_details(row):
    """Get step therapy details with column name fallback for DB compatibility."""
    requirement = row.get('Step_1_Requirement') or row.get('Step_Therapy_Requirements') or 'Not specified'
    duration = row.get('Step_1_Duration') or row.get('Step_Therapy_Duration') or 'Trial duration not specified'
    return str(requirement), str(duration)

# ============================================================================
# GUIDED DATA COLLECTION HELPERS
# ============================================================================

def analyze_parsed_data(parsed_data: dict) -> DataCollectionState:
    """Convert parsed AI data into a DataCollectionState."""
    return DataCollectionState(
        state=parsed_data.get('state'),
        payer=parsed_data.get('payer'),
        drug_class=parsed_data.get('drug_class'),
        diagnosis=parsed_data.get('diagnosis'),
        age=parsed_data.get('age'),
        prior_medications=parsed_data.get('prior_medications', [])
    )

def get_quality_indicator_html(score: int, description: str) -> str:
    """Generate HTML for quality indicator badge."""
    if score >= 90:
        color_class = "quality-excellent"
        icon = "üéØ"
    elif score >= 70:
        color_class = "quality-good"
        icon = "‚úÖ"
    elif score >= 50:
        color_class = "quality-fair"
        icon = "‚ö†Ô∏è"
    else:
        color_class = "quality-limited"
        icon = "üìä"
    
    return f'''
    <div class="{color_class}" style="padding: 0.75rem 1rem; border-radius: 8px; margin: 1rem 0; display: inline-block;">
        <span style="font-size: 1.1rem;">{icon}</span>
        <strong>Search Quality: {score}%</strong> ‚Äî {description}
    </div>
    '''

def render_gap_analysis_ui(policy_row: dict, medication_trials: List[MedicationTrial], unique_key: str) -> Tuple[bool, List[MedicationTrial]]:
    """
    Render the gap analysis UI for a specific policy.
    Returns (ready_for_pa, updated_medication_trials)
    """
    # Perform gap analysis
    gap = GapAnalysis(
        policy_requirements=policy_row,
        extracted_medications=medication_trials
    )
    results = gap.analyze()
    
    # Header with completeness score
    completeness = results['completeness_score']
    if completeness >= 100:
        status_color = "#059669"  # Green
        status_icon = "‚úÖ"
        status_text = "Ready for PA"
    elif completeness >= 50:
        status_color = "#D97706"  # Amber
        status_icon = "‚ö†Ô∏è"
        status_text = "Missing Details"
    else:
        status_color = "#DC2626"  # Red
        status_icon = "üî¥"
        status_text = "Incomplete"
    
    st.markdown(f"""
    <div style="background: linear-gradient(135deg, #F8FAFC 0%, #F1F5F9 100%); 
                border: 2px solid {status_color}; border-radius: 12px; padding: 1.25rem; margin: 1rem 0;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <div style="font-weight: 700; color: #1E293B; font-size: 1.1rem;">
                üìã Step Therapy Documentation Check
            </div>
            <div style="background: {status_color}; color: white; padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.85rem;">
                {status_icon} {status_text} ({completeness}%)
            </div>
        </div>
    """, unsafe_allow_html=True)
    
    # Show what's required
    step_req = policy_row.get('Step_1_Requirement', 'Not specified')
    step_duration = policy_row.get('Step_1_Duration', '8 weeks each')
    
    st.markdown(f"""
        <div style="background: white; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
            <div style="color: #64748B; font-size: 0.85rem; margin-bottom: 0.25rem;">Policy Requirement</div>
            <div style="color: #1E293B; font-weight: 600;">{step_req}</div>
            <div style="color: #64748B; font-size: 0.85rem; margin-top: 0.25rem;">Duration: {step_duration}</div>
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # If there are gaps, show the medication detail form
    updated_trials = medication_trials.copy()
    
    if results['medication_gaps'] or not results['ready_for_pa']:
        st.markdown("#### üíä Complete Medication Details")
        st.markdown("*Fill in missing details to generate a strong PA letter:*")
        
        for i, trial in enumerate(medication_trials):
            completeness_pct, missing = trial.calculate_completeness()
            
            # Medication card header
            if completeness_pct == 100:
                med_status = "‚úÖ"
                border_color = "#059669"
            elif completeness_pct > 0:
                med_status = "‚ö†Ô∏è"
                border_color = "#D97706"
            else:
                med_status = "üî¥"
                border_color = "#DC2626"
            
            with st.container():
                st.markdown(f"""
                <div style="border-left: 4px solid {border_color}; padding-left: 1rem; margin: 1rem 0;">
                    <div style="font-weight: 600; color: #1E293B; font-size: 1rem;">
                        {med_status} {trial.medication_name}
                        <span style="color: #64748B; font-weight: 400; font-size: 0.85rem; margin-left: 0.5rem;">
                            ({trial.drug_class or 'Unknown class'})
                        </span>
                    </div>
                </div>
                """, unsafe_allow_html=True)
                
                # Input fields in columns
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    # Dose input with reference info
                    dose_help = ""
                    if trial.therapeutic_dose_min and trial.therapeutic_dose_max:
                        dose_help = f"Therapeutic: {trial.therapeutic_dose_min}-{trial.therapeutic_dose_max} mg/day"
                    
                    dose_input = st.text_input(
                        "Dose",
                        value=trial.dose or "",
                        placeholder="e.g., 100mg/day",
                        key=f"dose_{unique_key}_{i}",
                        help=dose_help
                    )
                    if dose_input:
                        updated_trials[i].dose = dose_input
                
                with col2:
                    # Duration input
                    duration_help = f"Minimum recommended: {trial.recommended_duration_weeks or 8} weeks"
                    duration_input = st.number_input(
                        "Duration (weeks)",
                        min_value=1,
                        max_value=52,
                        value=trial.duration_weeks or 8,
                        key=f"duration_{unique_key}_{i}",
                        help=duration_help
                    )
                    updated_trials[i].duration_weeks = duration_input
                
                with col3:
                    # Reason stopped dropdown
                    reason_options = ["Select reason..."] + DISCONTINUATION_REASONS
                    current_idx = 0
                    if trial.reason_stopped and trial.reason_stopped in DISCONTINUATION_REASONS:
                        current_idx = DISCONTINUATION_REASONS.index(trial.reason_stopped) + 1
                    
                    reason_input = st.selectbox(
                        "Reason Stopped",
                        options=reason_options,
                        index=current_idx,
                        key=f"reason_{unique_key}_{i}"
                    )
                    if reason_input != "Select reason...":
                        updated_trials[i].reason_stopped = reason_input
        
        # Option to add another medication
        st.markdown("---")
        with st.expander("‚ûï Add Another Failed Medication"):
            add_col1, add_col2 = st.columns(2)
            with add_col1:
                new_med_name = st.text_input(
                    "Medication Name",
                    placeholder="e.g., Topiramate",
                    key=f"new_med_{unique_key}"
                )
            with add_col2:
                new_med_class = st.selectbox(
                    "Drug Class",
                    options=["Select...", "Beta-blocker", "Anticonvulsant", "Antidepressant", "CCB", "Triptan", "Other"],
                    key=f"new_class_{unique_key}"
                )
            
            if st.button("Add Medication", key=f"add_med_btn_{unique_key}"):
                if new_med_name and new_med_class != "Select...":
                    new_trial = MedicationTrial(
                        medication_name=new_med_name.title(),
                        drug_class=new_med_class
                    )
                    updated_trials.append(new_trial)
                    st.success(f"Added {new_med_name}")
                    st.rerun()
    
    # Re-check if ready after potential updates
    updated_gap = GapAnalysis(
        policy_requirements=policy_row,
        extracted_medications=updated_trials
    )
    updated_results = updated_gap.analyze()
    
    # If still not ready, show Next Steps guidance
    if not updated_results['ready_for_pa']:
        render_next_steps_guidance(
            policy_row=policy_row,
            gap_results=updated_results,
            medication_trials=updated_trials,
            unique_key=unique_key
        )
    
    return updated_results['ready_for_pa'], updated_trials


def render_next_steps_guidance(policy_row: dict, gap_results: dict, medication_trials: List[MedicationTrial], unique_key: str):
    """
    Render guidance for cases that don't meet PA requirements.
    Focuses on process/workflow options without making clinical recommendations.
    """
    step_req = policy_row.get('Step_1_Requirement', 'Not specified')
    
    # Count what we have
    classes_documented = len(set(t.drug_class for t in medication_trials if t.drug_class))
    
    # Determine what's needed based on policy
    required_classes = 2  # Default
    if '1 oral preventive' in step_req.lower() or '‚â•1' in step_req:
        required_classes = 1
    elif '2 oral preventive' in step_req.lower() or '‚â•2' in step_req:
        required_classes = 2
    elif '3' in step_req:
        required_classes = 3
    
    classes_needed = max(0, required_classes - classes_documented)
    
    st.markdown("---")
    st.markdown("""
    <div style="background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%); 
                border: 2px solid #F59E0B; border-radius: 12px; padding: 1.5rem; margin: 1rem 0;">
        <div style="font-weight: 700; color: #92400E; font-size: 1.15rem; margin-bottom: 1rem;">
            üìã This PA Requires Additional Documentation
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    # Show the gap summary
    st.markdown(f"""
    <div style="background: white; border-radius: 8px; padding: 1rem; margin-bottom: 1rem; border: 1px solid #E5E7EB;">
        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
            <span style="color: #64748B;">Policy requires:</span>
            <span style="color: #1E293B; font-weight: 600;">{step_req}</span>
        </div>
        <div style="display: flex; justify-content: space-between;">
            <span style="color: #64748B;">Currently documented:</span>
            <span style="color: {'#059669' if classes_documented >= required_classes else '#DC2626'}; font-weight: 600;">
                {classes_documented} of {required_classes} medication class{'es' if required_classes > 1 else ''}
            </span>
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("#### Your Options")
    
    # Option 1: Document another trial (if classes are missing)
    if classes_needed > 0:
        with st.expander("üìù **Option 1: Document Additional Trial(s)**", expanded=True):
            st.markdown(f"""
            If the patient has tried other preventive medications that aren't documented in the note, 
            you can add them above or update the clinical note.
            
            **What to document for each medication:**
            - Medication name and dose
            - Duration of trial (typically 8+ weeks required)
            - Reason for discontinuation
            """)
            
            # Template for documentation
            st.markdown("**Documentation template:**")
            st.code("""Patient also completed trial of [MEDICATION NAME] at [DOSE] 
for [DURATION] weeks from [START DATE] to [END DATE]. 
Treatment was discontinued due to [REASON: inefficacy/side effects/etc.].""", language=None)
    
    # Option 2: Medical necessity exception
    with st.expander("üìã **Option 2: Request Medical Necessity Exception**", expanded=False):
        st.markdown("""
        If the patient has valid reasons why they cannot complete the required step therapy, 
        you may request an exception. 
        
        **Common grounds for exceptions** (check if applicable):
        """)
        
        exception_reasons = [
            ("Cardiovascular contraindication", "Beta-blockers contraindicated due to bradycardia, heart block, asthma, etc."),
            ("Pregnancy or planning pregnancy", "Valproate and topiramate are teratogenic"),
            ("Prior adverse reaction", "Documented serious adverse event to required medication class"),
            ("Drug interaction", "Required medication interacts with current essential therapy"),
            ("Already tried outside your care", "Patient completed trials with previous provider (obtain records)"),
        ]
        
        for reason, explanation in exception_reasons:
            st.checkbox(reason, key=f"exception_{unique_key}_{reason[:10]}", help=explanation)
        
        st.markdown("---")
        st.markdown("**Exception request template:**")
        st.code("""MEDICAL NECESSITY EXCEPTION REQUEST

Patient cannot complete standard step therapy due to:
‚òê [SPECIFIC CONTRAINDICATION/REASON]

Clinical documentation:
‚Ä¢ [RELEVANT DIAGNOSIS OR CONDITION]
‚Ä¢ [SUPPORTING LAB VALUES OR TEST RESULTS IF APPLICABLE]

The requested medication is medically necessary because:
‚Ä¢ Standard step therapy poses unacceptable risk due to [REASON]
‚Ä¢ No suitable alternatives exist within the required medication classes
‚Ä¢ Delay in treatment would result in [CLINICAL CONSEQUENCE]

References:
‚Ä¢ [RELEVANT GUIDELINE OR LITERATURE IF APPLICABLE]""", language=None)
    
    # Option 3: Refer to specialist
    with st.expander("üë®‚Äç‚öïÔ∏è **Option 3: Refer to Headache Specialist**", expanded=False):
        st.markdown("""
        For complex cases, a headache specialist may be able to:
        - Provide additional documentation supporting medical necessity
        - Navigate complex step therapy requirements
        - Offer treatments not typically managed in primary care
        - Serve as a resource for appeals if PA is denied
        """)
        
        # Get state from context if available
        patient_state = policy_row.get('State', 'your state')
        if patient_state and patient_state != 'ALL':
            st.info(f"üí° Use the **Headache Vault Index** in Clinical Tools to find specialists in {patient_state}")
        
        st.markdown("""
        **Referral letter template:**
        """)
        st.code("""Dear Colleague,

I am referring this patient for headache specialty consultation.

Diagnosis: [DIAGNOSIS]
Current frequency: [X] headache days per month

Prior treatments attempted:
‚Ä¢ [MEDICATION 1]: [OUTCOME]
‚Ä¢ [MEDICATION 2]: [OUTCOME]

Reason for referral:
The patient's insurance requires [SPECIFIC STEP THERAPY] prior to approval 
of [REQUESTED MEDICATION]. I am seeking your expertise in managing this 
complex case and/or supporting a medical necessity exception.

Thank you for your consultation.""", language=None)
    
    # Option 4: Begin required step therapy
    with st.expander("‚è±Ô∏è **Option 4: Begin Required Step Therapy**", expanded=False):
        st.markdown("""
        If clinically appropriate, you may choose to start the patient on the required 
        step therapy medication(s).
        
        **Typical requirements:**
        - Minimum 8 weeks at therapeutic dose
        - Document specific reason for discontinuation
        - Some policies accept trials from any time in patient history
        
        **Common oral preventives by class:**
        """)
        
        preventive_table = """
| Class | Medications | Typical Therapeutic Dose | Common Side Effects |
|-------|------------|-------------------------|---------------------|
| Beta-blocker | Propranolol, Metoprolol | 80-240 mg/day | Fatigue, bradycardia |
| Anticonvulsant | Topiramate, Valproate | 100-200 mg/day | Cognitive effects, weight changes |
| Antidepressant | Amitriptyline, Venlafaxine | 50-150 mg/day | Sedation, dry mouth |
| CCB | Verapamil | 240-480 mg/day | Constipation, edema |
"""
        st.markdown(preventive_table)
        
        st.warning("""
        ‚ö†Ô∏è **Note:** This table is for reference only. Medication selection should be based on 
        individual patient factors, contraindications, and clinical judgment.
        """)
    
    # Option 5: Submit PA anyway (for documentation/appeal setup)
    with st.expander("üì§ **Option 5: Submit PA for Denial (to enable appeal)**", expanded=False):
        st.markdown("""
        In some cases, it may be strategic to submit the PA request knowing it will likely be denied:
        
        **Why submit if likely denied?**
        - Creates formal record of medical necessity
        - Initiates appeal rights and timeline
        - Some payers approve requests that initially appear to not meet criteria
        - Documents the barrier for patient and payer records
        
        **Appeal process typically includes:**
        1. Peer-to-peer review (physician-to-physician call)
        2. Written appeal with additional documentation
        3. External review (if internal appeals exhausted)
        
        **If you choose this path:**
        - Include all available documentation in initial submission
        - Note in the letter that you are requesting exception review
        - Be prepared for peer-to-peer call within 24-72 hours
        """)

# ============================================================================
# NATIONAL FALLBACK SEARCH - Added Jan 2026
# ============================================================================
def search_policies_with_fallback(db_b, state, payer=None, drug_class=None):
    """
    Search for policies with automatic fallback to national (ALL) entries
    and drug class cascading for preventive gepants.
    
    Priority:
    1. State + Payer + Drug Class specific
    2. National (ALL) + Payer + Drug Class specific
    3. For Gepants (Preventive): Try Qulipta ‚Üí CGRP mAbs cascade
    
    Returns: (results_df, fallback_used: bool, fallback_message: str)
    """
    fallback_used = False
    fallback_message = ""
    
    # Step 1: Try state-specific search
    query = db_b[db_b['State'] == state].copy()
    query = query.reset_index(drop=True)  # Reset index to avoid boolean mask issues
    
    # Apply payer filter with flexible matching
    if payer:
        # Extract key payer identifier for flexible matching
        payer_lower = payer.lower()
        
        # Try to extract the core payer name for better matching
        payer_keywords = []
        if 'horizon' in payer_lower:
            payer_keywords = ['horizon']
        elif 'aetna' in payer_lower:
            payer_keywords = ['aetna']
        elif 'united' in payer_lower or 'uhc' in payer_lower:
            payer_keywords = ['united', 'uhc']
        elif 'cigna' in payer_lower:
            payer_keywords = ['cigna']
        elif 'anthem' in payer_lower or 'elevance' in payer_lower:
            payer_keywords = ['anthem', 'elevance']
        elif 'bcbs' in payer_lower or 'blue cross' in payer_lower:
            payer_keywords = ['bcbs', 'blue cross', 'blue shield']
        elif 'humana' in payer_lower:
            payer_keywords = ['humana']
        elif 'kaiser' in payer_lower:
            payer_keywords = ['kaiser']
        elif 'highmark' in payer_lower:
            payer_keywords = ['highmark']
        elif 'independence' in payer_lower:
            payer_keywords = ['independence']
        else:
            # Use first significant word as keyword
            payer_keywords = [payer.split()[0].lower()] if payer.split() else [payer_lower]
        
        # Build flexible payer match
        payer_mask = pd.Series([False] * len(query))
        for kw in payer_keywords:
            payer_mask = payer_mask | query['Payer_Name'].str.contains(kw, case=False, na=False)
        
        payer_query = query[payer_mask]
        
        # If no state match, try national fallback
        if len(payer_query) == 0:
            national_query = db_b[db_b['State'] == 'ALL'].copy()
            national_query = national_query.reset_index(drop=True)  # Reset index
            national_mask = pd.Series([False] * len(national_query))
            for kw in payer_keywords:
                national_mask = national_mask | national_query['Payer_Name'].str.contains(kw, case=False, na=False)
            national_payer = national_query[national_mask]
            
            if len(national_payer) > 0:
                query = national_payer
                fallback_used = True
                fallback_message = f"‚ÑπÔ∏è No {state}-specific policy for {payer}. Showing **national baseline** policy. State-specific rules may vary."
            else:
                query = payer_query  # Empty
        else:
            query = payer_query
    
    # Apply drug class filter with cascading for preventive gepants
    if drug_class:
        drug_query = query[query['Drug_Class'] == drug_class]
        
        # If no results, try cascading fallbacks
        if len(drug_query) == 0:
            cascade_classes = []
            cascade_message = ""
            
            # Define cascade order for preventive gepants
            if drug_class == 'Gepants (Preventive)':
                cascade_classes = ['Qulipta', 'CGRP mAbs']
                cascade_message = "Nurtec Preventive"
            elif drug_class == 'Qulipta':
                cascade_classes = ['Gepants (Preventive)', 'CGRP mAbs']
                cascade_message = "Qulipta"
            
            # Try cascade classes
            for cascade_class in cascade_classes:
                cascade_query = query[query['Drug_Class'] == cascade_class]
                if len(cascade_query) > 0:
                    drug_query = cascade_query
                    fallback_used = True
                    fallback_message = f"‚ÑπÔ∏è No {drug_class} policy found. Showing **{cascade_class}** policy (similar step therapy requirements)."
                    break
            
            # If still no results, try national fallback
            if len(drug_query) == 0 and not fallback_used:
                national_query = db_b[db_b['State'] == 'ALL'].copy()
                national_query = national_query.reset_index(drop=True)  # Reset index
                if payer and 'payer_keywords' in dir():
                    # Use same flexible matching
                    national_mask = pd.Series([False] * len(national_query))
                    for kw in payer_keywords:
                        national_mask = national_mask | national_query['Payer_Name'].str.contains(kw, case=False, na=False)
                    national_query = national_query[national_mask]
                
                # Try original drug class nationally
                national_drug = national_query[national_query['Drug_Class'] == drug_class]
                
                # If not found, try cascade classes nationally
                if len(national_drug) == 0:
                    for cascade_class in cascade_classes:
                        national_drug = national_query[national_query['Drug_Class'] == cascade_class]
                        if len(national_drug) > 0:
                            fallback_message = f"‚ÑπÔ∏è No {state}-specific {drug_class} policy. Showing **national {cascade_class}** baseline."
                            break
                
                if len(national_drug) > 0:
                    drug_query = national_drug
                    fallback_used = True
                    if not fallback_message:
                        fallback_message = f"‚ÑπÔ∏è No {state}-specific policy for {drug_class}. Showing **national baseline** policy."
        
        query = drug_query
    
    return query, fallback_used, fallback_message


# ============================================================================
# FORMULARY TIER MAP ‚Äî Helper Functions (v3.0)
# ============================================================================

# Map common drug name variations to canonical Drug_Name in Formulary_Tier_Map
DRUG_NAME_MAP = {
    'aimovig': 'Aimovig', 'erenumab': 'Aimovig',
    'emgality': 'Emgality', 'galcanezumab': 'Emgality',
    'ajovy': 'Ajovy', 'fremanezumab': 'Ajovy',
    'vyepti': 'Vyepti', 'eptinezumab': 'Vyepti',
    'nurtec': 'Nurtec ODT', 'nurtec odt': 'Nurtec ODT', 'rimegepant': 'Nurtec ODT',
    'ubrelvy': 'Ubrelvy', 'ubrogepant': 'Ubrelvy',
    'qulipta': 'Qulipta', 'atogepant': 'Qulipta',
    'botox': 'Botox', 'onabotulinumtoxina': 'Botox',
    'zavzpret': 'Zavzpret', 'zavegepant': 'Zavzpret',
}

def extract_selected_drug_name(parsed_data: dict) -> str:
    """Extract canonical drug name from parsed clinical note or sidebar selection."""
    if not parsed_data:
        return ""
    # Check common fields for drug mentions
    for field in ['drug', 'medication', 'drug_class', 'requested_medication']:
        val = parsed_data.get(field, '')
        if val:
            for keyword, canonical in DRUG_NAME_MAP.items():
                if keyword in str(val).lower():
                    return canonical
    return ""

def lookup_formulary_for_policy(formulary_df, vault_payer_id: str, drug_class: str):
    """
    Look up formulary tier data for a specific payer + drug class.
    Returns a DataFrame of drugs with their formulary status, sorted Preferred-first.
    """
    if formulary_df is None or formulary_df.empty:
        return pd.DataFrame()
    mask = (
        (formulary_df['Vault_Payer_ID'] == vault_payer_id) &
        (formulary_df['Drug_Class'] == drug_class)
    )
    tier_data = formulary_df[mask].copy()
    if tier_data.empty:
        return tier_data
    # Sort: Preferred first, then Non-Preferred, then Restricted, then Excluded
    status_order = {'Preferred': 0, 'Non-Preferred': 1, 'Restricted': 2, 'Excluded': 3}
    tier_data['_sort'] = tier_data['Formulary_Status'].map(status_order).fillna(4)
    tier_data = tier_data.sort_values('_sort').drop(columns=['_sort'])
    return tier_data

def get_formulary_status_badge(status: str) -> str:
    """Return color-coded HTML badge for formulary status."""
    colors = {
        'Preferred': ('#059669', '#D1FAE5', '‚úÖ'),
        'Non-Preferred': ('#D97706', '#FEF3C7', '‚ö†Ô∏è'),
        'Restricted': ('#DC2626', '#FEE2E2', 'üî¥'),
        'Excluded': ('#991B1B', '#FEE2E2', '‚ùå'),
    }
    color, bg, icon = colors.get(status, ('#6B7280', '#F3F4F6', '‚ùì'))
    return f'<span style="background:{bg};color:{color};padding:2px 8px;border-radius:4px;font-size:0.85em;font-weight:600;">{icon} {status}</span>'

def get_confidence_disclaimer(tier_data) -> str:
    """Return disclaimer HTML if any rows have low-confidence data."""
    if tier_data.empty:
        return ""
    low_conf = tier_data[tier_data['Confidence'].isin(['PBM-Inferred', 'Gap-Manual-Review'])]
    if not low_conf.empty:
        return '<div style="background:#FEF3C7;border:1px solid #F59E0B;border-radius:6px;padding:8px 12px;margin-top:8px;font-size:0.82em;">‚ö†Ô∏è <strong>Note:</strong> Some formulary data is estimated. Verify with the payer before submission.</div>'
    return ""

def get_preferred_drug_suggestion(tier_data, selected_drug: str) -> str:
    """If selected drug is Non-Preferred, suggest a Preferred alternative."""
    if tier_data.empty or not selected_drug:
        return ""
    sel_rows = tier_data[tier_data['Drug_Name'] == selected_drug]
    if sel_rows.empty:
        return ""
    sel_status = sel_rows.iloc[0].get('Formulary_Status', '')
    if sel_status in ('Non-Preferred', 'Restricted', 'Excluded'):
        preferred = tier_data[tier_data['Formulary_Status'] == 'Preferred']
        if not preferred.empty:
            alt = preferred.iloc[0]['Drug_Name']
            alt_tier = preferred.iloc[0].get('Tier', '')
            return f'<div style="background:#EFF6FF;border:1px solid #BFDBFE;border-radius:6px;padding:8px 12px;margin-top:8px;font-size:0.85em;">üí° <strong>{alt}</strong> is Preferred{f" ({alt_tier})" if alt_tier else ""} on this formulary. Switching may avoid additional PA barriers.</div>'
    return ""

def build_formulary_html_table(tier_data, selected_drug: str = "") -> str:
    """Build an HTML mini-table showing drug-level formulary details."""
    if tier_data.empty:
        return '<div style="color:#6B7280;font-size:0.85em;padding:4px 0;">No formulary data available for this payer/drug class.</div>'
    rows_html = ""
    for _, r in tier_data.iterrows():
        drug = r.get('Drug_Name', '?')
        status = r.get('Formulary_Status', '?')
        tier = r.get('Tier', '‚Äî')
        step = r.get('Step_Within_Class', '‚Äî')
        ql = r.get('Quantity_Limit', '‚Äî')
        # Clean NaN values
        tier = tier if pd.notna(tier) and str(tier).strip() else '‚Äî'
        step = step if pd.notna(step) and str(step).strip() else '‚Äî'
        ql = ql if pd.notna(ql) and str(ql).strip() else '‚Äî'
        badge = get_formulary_status_badge(status)
        highlight = ' style="background:#EFF6FF;"' if drug == selected_drug else ''
        rows_html += f'<tr{highlight}><td style="padding:4px 8px;font-weight:{"700" if drug == selected_drug else "400"}">{drug}</td><td style="padding:4px 8px;">{badge}</td><td style="padding:4px 8px;font-size:0.85em;">{tier}</td><td style="padding:4px 8px;font-size:0.85em;">{step}</td><td style="padding:4px 8px;font-size:0.85em;">{ql}</td></tr>'
    return f'''<table style="width:100%;border-collapse:collapse;font-size:0.9em;margin-top:6px;">
<thead><tr style="border-bottom:2px solid #E5E7EB;text-align:left;">
<th style="padding:4px 8px;">Drug</th><th style="padding:4px 8px;">Status</th><th style="padding:4px 8px;">Tier</th><th style="padding:4px 8px;">Within-Class Step</th><th style="padding:4px 8px;">Quantity Limit</th>
</tr></thead><tbody>{rows_html}</tbody></table>'''


def send_lead_to_monday(name, email, practice, state, payer, drug_class, notes):
    """Send lead data to Monday.com CRM board"""


def check_criteria_met(step_requirements, prior_medications, diagnosis):
    """
    Check if patient's documented history meets step therapy requirements.
    Returns list of (requirement, met_status, details) tuples.
    """
    criteria_status = []
    step_req_lower = step_requirements.lower() if step_requirements else ''
    
    # Handle both old format (list of strings) and new format (list of dicts)
    prior_meds_lower = []
    if prior_medications:
        for m in prior_medications:
            if isinstance(m, str):
                prior_meds_lower.append(m.lower())
            elif isinstance(m, dict) and m.get('name'):
                prior_meds_lower.append(m['name'].lower())
    
    # Common preventive medication classes
    beta_blockers = ['propranolol', 'metoprolol', 'atenolol', 'nadolol', 'timolol']
    anticonvulsants = ['topiramate', 'topamax', 'valproate', 'depakote', 'divalproex', 'gabapentin']
    antidepressants = ['amitriptyline', 'nortriptyline', 'venlafaxine', 'duloxetine', 'effexor', 'cymbalta']
    ccbs = ['verapamil', 'flunarizine']
    triptans = ['sumatriptan', 'rizatriptan', 'eletriptan', 'zolmitriptan', 'naratriptan', 'frovatriptan', 'almotriptan']
    
    # Check for oral preventive requirements (CGRP mAbs)
    if '2 oral preventive' in step_req_lower or ('2' in step_req_lower and 'preventive' in step_req_lower) or 'conventional oral' in step_req_lower:
        classes_tried = 0
        meds_found = []
        
        for med in prior_meds_lower:
            if any(bb in med for bb in beta_blockers) and 'Beta-blocker' not in [m.split(' (')[0] for m in meds_found]:
                classes_tried += 1
                meds_found.append(f"Beta-blocker ({med.title()})")
            elif any(ac in med for ac in anticonvulsants) and 'Anticonvulsant' not in [m.split(' (')[0] for m in meds_found]:
                classes_tried += 1
                meds_found.append(f"Anticonvulsant ({med.title()})")
            elif any(ad in med for ad in antidepressants) and 'Antidepressant' not in [m.split(' (')[0] for m in meds_found]:
                classes_tried += 1
                meds_found.append(f"Antidepressant ({med.title()})")
            elif any(ccb in med for ccb in ccbs) and 'CCB' not in [m.split(' (')[0] for m in meds_found]:
                classes_tried += 1
                meds_found.append(f"CCB ({med.title()})")
        
        if classes_tried >= 2:
            criteria_status.append(("‚â•2 oral preventive classes", True, f"{', '.join(meds_found[:3])}"))
        elif classes_tried == 1:
            criteria_status.append(("‚â•2 oral preventive classes", False, f"Only 1 class: {meds_found[0]}"))
        else:
            criteria_status.append(("‚â•2 oral preventive classes", False, "No oral preventives documented"))
    
    # Check for triptan requirements (Gepants)
    if 'triptan' in step_req_lower:
        triptans_tried = []
        for med in prior_meds_lower:
            for t in triptans:
                if t in med and t.title() not in triptans_tried:
                    triptans_tried.append(t.title())
        
        if '2' in step_req_lower and 'triptan' in step_req_lower:
            if len(triptans_tried) >= 2:
                criteria_status.append(("‚â•2 triptans tried", True, f"{', '.join(triptans_tried[:2])}"))
            elif len(triptans_tried) == 1:
                criteria_status.append(("‚â•2 triptans tried", False, f"Only 1: {triptans_tried[0]}"))
            else:
                criteria_status.append(("‚â•2 triptans tried", False, "No triptans documented"))
    
    # Check for verapamil/lithium requirements (Cluster)
    if 'verapamil' in step_req_lower or 'lithium' in step_req_lower:
        verapamil_tried = any('verapamil' in med for med in prior_meds_lower)
        lithium_tried = any('lithium' in med for med in prior_meds_lower)
        
        if ' or ' in step_req_lower:  # verapamil OR lithium
            if verapamil_tried or lithium_tried:
                med_name = 'Verapamil' if verapamil_tried else 'Lithium'
                criteria_status.append(("Verapamil OR lithium failure", True, f"{med_name} trial documented"))
            else:
                criteria_status.append(("Verapamil OR lithium failure", False, "Neither documented"))
        elif ' and ' in step_req_lower:  # verapamil AND lithium
            if verapamil_tried and lithium_tried:
                criteria_status.append(("Verapamil AND lithium failure", True, "Both documented"))
            else:
                missing = []
                if not verapamil_tried: missing.append("verapamil")
                if not lithium_tried: missing.append("lithium")
                criteria_status.append(("Verapamil AND lithium failure", False, f"Missing: {', '.join(missing)}"))
    
    return criteria_status

    
    # Get API key from secrets
    try:
        api_key = st.secrets.get("MONDAY_API_KEY", None)
    except:
        api_key = None
    
    if not api_key:
        return False, "Monday.com API key not configured"
    
    # Monday.com board and group IDs
    BOARD_ID = 18397061224  # Headache Vault - Contacts & Prospects
    GROUP_ID = "group_mkzxdy1j"  # Demo Users group
    
    # Build column values
    column_values = {
        "email_mkzxqtxn": {"email": email, "text": email},
        "text_mkzxpp92": state,  # State
        "text_mkzxdt7e": practice if practice else "Demo User",  # Specialty/Practice
        "color_mkzx5w7m": {"label": "Demo User"},  # Contact Type
        "color_mkzxsgea": {"label": "PA Demo"},  # Lead Source
        "color_mkzxp42x": {"label": "New Lead"},  # Sales Stage
        "date_mkzxqhxz": {"date": datetime.now().strftime("%Y-%m-%d")},  # First Contact Date
        "long_text_mkzxe3nf": {"text": f"PA Demo Lead\\nPayer: {payer}\\nDrug: {drug_class}\\n{notes}"}  # Notes
    }
    
    # GraphQL mutation
    mutation = """
    mutation ($boardId: ID!, $groupId: String!, $itemName: String!, $columnValues: JSON!) {
        create_item (
            board_id: $boardId,
            group_id: $groupId,
            item_name: $itemName,
            column_values: $columnValues
        ) {
            id
        }
    }
    """
    
    variables = {
        "boardId": str(BOARD_ID),
        "groupId": GROUP_ID,
        "itemName": name if name else email.split("@")[0],
        "columnValues": json.dumps(column_values)
    }
    
    headers = {
        "Authorization": api_key,
        "Content-Type": "application/json"
    }
    
    try:
        response = requests.post(
            "https://api.monday.com/v2",
            json={"query": mutation, "variables": variables},
            headers=headers
        )
        
        if response.status_code == 200:
            result = response.json()
            if "data" in result and result["data"]["create_item"]:
                return True, result["data"]["create_item"]["id"]
            else:
                return False, result.get("errors", "Unknown error")
        else:
            return False, f"HTTP {response.status_code}"
    except Exception as e:
        return False, str(e)

# Initialize session state (unified data flow)
SessionStateManager.initialize()

# Guided data collection state
if 'data_collection_state' not in st.session_state:
    st.session_state.data_collection_state = None

# Email capture state
if 'show_email_form' not in st.session_state:
    st.session_state.show_email_form = False
if 'pa_text_for_email' not in st.session_state:
    st.session_state.pa_text_for_email = None
if 'pa_email_context' not in st.session_state:
    st.session_state.pa_email_context = {}
if 'email_captures' not in st.session_state:
    st.session_state.email_captures = []

# Load data
# Unpack databases with descriptive names
payer_registry, payer_policies, formulary_tier_map, denial_codes, pediatric_overrides, state_regulations, icd10_codes, therapeutic_doses, otc_medications = load_databases()

# Aliases matching schema doc convention
db_a = payer_registry
db_b = payer_policies
db_d = formulary_tier_map
db_c = denial_codes

# Create aliases for backward compatibility during transition
db_a = payer_registry
db_b = payer_policies
db_c = denial_codes
db_e = pediatric_overrides
db_f = state_regulations
icd10 = icd10_codes
therapeutic = therapeutic_doses
otc = otc_medications

# Helper function to create copy button HTML
def create_copy_button(text, button_id):
    """Create a copy-to-clipboard button"""
    escaped_text = text.replace("'", "\\'").replace("\n", "\\n")
    return f"""
    <button onclick="navigator.clipboard.writeText('{escaped_text}').then(() => {{
        const btn = document.getElementById('{button_id}');
        const original = btn.innerHTML;
        btn.innerHTML = '‚úÖ Copied!';
        btn.style.background = '#10B981';
        setTimeout(() => {{
            btn.innerHTML = original;
            btn.style.background = '#4B0082';
        }}, 2000);
    }})" id="{button_id}" class="copy-button">
        üìã Copy
    </button>
    """

# ============================================================================
# STATE & AGE HALLUCINATION GUARDS (50-state + DC validator)
# ============================================================================

# Every state's full name (used for exact substring match)
STATE_FULL_NAMES = {
    'AL': 'alabama', 'AK': 'alaska', 'AZ': 'arizona', 'AR': 'arkansas',
    'CA': 'california', 'CO': 'colorado', 'CT': 'connecticut', 'DE': 'delaware',
    'FL': 'florida', 'GA': 'georgia', 'HI': 'hawaii', 'ID': 'idaho',
    'IL': 'illinois', 'IN': 'indiana', 'IA': 'iowa', 'KS': 'kansas',
    'KY': 'kentucky', 'LA': 'louisiana', 'ME': 'maine', 'MD': 'maryland',
    'MA': 'massachusetts', 'MI': 'michigan', 'MN': 'minnesota', 'MS': 'mississippi',
    'MO': 'missouri', 'MT': 'montana', 'NE': 'nebraska', 'NV': 'nevada',
    'NH': 'new hampshire', 'NJ': 'new jersey', 'NM': 'new mexico', 'NY': 'new york',
    'NC': 'north carolina', 'ND': 'north dakota', 'OH': 'ohio', 'OK': 'oklahoma',
    'OR': 'oregon', 'PA': 'pennsylvania', 'RI': 'rhode island', 'SC': 'south carolina',
    'SD': 'south dakota', 'TN': 'tennessee', 'TX': 'texas', 'UT': 'utah',
    'VT': 'vermont', 'VA': 'virginia', 'WA': 'washington', 'WV': 'west virginia',
    'WI': 'wisconsin', 'WY': 'wyoming', 'DC': 'district of columbia',
}

# Abbreviations that collide with common English words ‚Äî need extra care.
AMBIGUOUS_ABBREVIATIONS = {
    'AL', 'AR', 'CO', 'DC', 'DE', 'HI', 'ID', 'IL', 'IN', 'LA',
    'MA', 'MD', 'ME', 'MI', 'MO', 'MT', 'NE', 'OH', 'OK', 'OR',
    'PA', 'VA', 'WA',
}

# Major cities ‚Üí state code. Ambiguous cities map to None.
CITY_TO_STATE = {
    # --- PA ---
    'philadelphia': 'PA', 'pittsburgh': 'PA', 'harrisburg': 'PA', 'allentown': 'PA',
    # --- NY ---
    'manhattan': 'NY', 'brooklyn': 'NY', 'buffalo': 'NY', 'queens': 'NY', 'bronx': 'NY',
    'staten island': 'NY', 'syracuse': 'NY', 'albany': 'NY',
    # --- CA ---
    'los angeles': 'CA', 'san francisco': 'CA', 'san diego': 'CA', 'sacramento': 'CA',
    'san jose': 'CA', 'fresno': 'CA', 'oakland': 'CA', 'long beach': 'CA',
    # --- TX ---
    'houston': 'TX', 'dallas': 'TX', 'austin': 'TX', 'san antonio': 'TX',
    'fort worth': 'TX', 'el paso': 'TX', 'lubbock': 'TX', 'corpus christi': 'TX',
    # --- FL ---
    'miami': 'FL', 'orlando': 'FL', 'tampa': 'FL', 'jacksonville': 'FL',
    'fort lauderdale': 'FL', 'st. petersburg': 'FL', 'tallahassee': 'FL',
    # --- IL ---
    'chicago': 'IL', 'naperville': 'IL', 'rockford': 'IL', 'peoria': 'IL',
    # --- OH ---
    'cleveland': 'OH', 'columbus': 'OH', 'cincinnati': 'OH', 'akron': 'OH', 'dayton': 'OH',
    # --- NJ ---
    'newark': 'NJ', 'jersey city': 'NJ', 'trenton': 'NJ', 'paterson': 'NJ',
    # --- MA ---
    'boston': 'MA', 'cambridge': 'MA', 'worcester': 'MA',
    # --- GA ---
    'atlanta': 'GA', 'savannah': 'GA', 'augusta': 'GA',
    # --- NC ---
    'charlotte': 'NC', 'raleigh': 'NC', 'durham': 'NC', 'greensboro': 'NC',
    # --- MI ---
    'detroit': 'MI', 'grand rapids': 'MI', 'ann arbor': 'MI', 'lansing': 'MI',
    # --- AZ ---
    'phoenix': 'AZ', 'tucson': 'AZ', 'scottsdale': 'AZ', 'mesa': 'AZ',
    # --- WA ---
    'seattle': 'WA', 'tacoma': 'WA', 'spokane': 'WA', 'bellevue': 'WA',
    # --- CO ---
    'denver': 'CO', 'colorado springs': 'CO', 'boulder': 'CO',
    # --- MN ---
    'minneapolis': 'MN', 'st. paul': 'MN', 'duluth': 'MN',
    # --- TN ---
    'nashville': 'TN', 'memphis': 'TN', 'knoxville': 'TN', 'chattanooga': 'TN',
    # --- IN ---
    'indianapolis': 'IN', 'fort wayne': 'IN', 'south bend': 'IN',
    # --- WI ---
    'milwaukee': 'WI', 'green bay': 'WI',
    # --- KY ---
    'louisville': 'KY', 'lexington': 'KY', 'bowling green': 'KY',
    # --- MD ---
    'baltimore': 'MD', 'bethesda': 'MD', 'silver spring': 'MD',
    # --- NV ---
    'las vegas': 'NV', 'reno': 'NV', 'henderson': 'NV',
    # --- NM ---
    'albuquerque': 'NM', 'santa fe': 'NM', 'las cruces': 'NM',
    # --- OK ---
    'oklahoma city': 'OK', 'tulsa': 'OK', 'norman': 'OK',
    # --- HI ---
    'honolulu': 'HI', 'maui': 'HI',
    # --- AK ---
    'anchorage': 'AK', 'fairbanks': 'AK', 'juneau': 'AK',
    # --- ID ---
    'boise': 'ID', 'nampa': 'ID',
    # --- IA ---
    'des moines': 'IA', 'cedar rapids': 'IA', 'iowa city': 'IA',
    # --- KS ---
    'wichita': 'KS', 'topeka': 'KS', 'overland park': 'KS',
    # --- LA ---
    'new orleans': 'LA', 'baton rouge': 'LA', 'shreveport': 'LA',
    # --- MO ---
    'st. louis': 'MO', 'st louis': 'MO',
    # --- MS ---
    'biloxi': 'MS', 'gulfport': 'MS',
    # --- MT ---
    'billings': 'MT', 'missoula': 'MT', 'great falls': 'MT', 'helena': 'MT',
    # --- NE ---
    'omaha': 'NE',
    # --- NH ---
    'nashua': 'NH',
    # --- OR ---
    'eugene': 'OR', 'bend': 'OR', 'medford': 'OR',
    # --- RI ---
    'providence': 'RI', 'warwick': 'RI', 'cranston': 'RI',
    # --- SC ---
    'myrtle beach': 'SC',
    # --- SD ---
    'sioux falls': 'SD', 'rapid city': 'SD',
    # --- UT ---
    'salt lake city': 'UT', 'provo': 'UT', 'ogden': 'UT',
    # --- VT ---
    'burlington': 'VT', 'montpelier': 'VT',
    # --- VA ---
    'richmond': 'VA', 'norfolk': 'VA', 'virginia beach': 'VA',
    # --- WV ---
    'huntington': 'WV', 'morgantown': 'WV',
    # --- AR ---
    'little rock': 'AR', 'fort smith': 'AR',
    # --- CT ---
    'hartford': 'CT', 'new haven': 'CT', 'stamford': 'CT', 'bridgeport': 'CT',
    # --- ND ---
    'fargo': 'ND', 'bismarck': 'ND', 'grand forks': 'ND',
    # --- WY ---
    'cheyenne': 'WY', 'casper': 'WY', 'laramie': 'WY',
    # --- DC ---
    'washington, d.c.': 'DC', 'washington dc': 'DC', 'washington, dc': 'DC',
    # --- AMBIGUOUS CITIES (exist in multiple states) ---
    'portland': None, 'springfield': None, 'kansas city': None, 'columbia': None,
    'aurora': None, 'arlington': None, 'charleston': None, 'rochester': None,
    'wilmington': None, 'jackson': None, 'lincoln': None, 'madison': None,
    'concord': None, 'dover': None, 'salem': None, 'greenville': None,
    'fayetteville': None,
}


def validate_extracted_state(parsed_state, note_text):
    """
    Validate Claude's state extraction against the actual note text.
    Returns: (validated_state_or_None, log_message_or_None)
    """
    if not parsed_state:
        return None, None
    
    state_code = str(parsed_state).upper().strip()
    
    if state_code not in STATE_FULL_NAMES:
        return None, f"Invalid state code: {parsed_state}"
    
    note_lower = note_text.lower()
    
    # CHECK 1: Full state name (with Washington DC special case)
    full_name = STATE_FULL_NAMES[state_code]
    
    if state_code == 'WA' and 'washington' in note_lower:
        if any(dc_hint in note_lower for dc_hint in ['d.c.', ' dc', 'district of columbia']):
            return None, f"Cleared state: Washington appears to be DC, not WA"
        return state_code, None
    
    if state_code == 'DC':
        if any(dc in note_lower for dc in ['washington, d.c.', 'washington dc', 'washington, dc', 'district of columbia']):
            return state_code, None
    
    if full_name in note_lower:
        return state_code, None
    
    # CHECK 2: Abbreviation pattern (safe regex)
    abbrev_lower = state_code.lower()
    
    if state_code not in AMBIGUOUS_ABBREVIATIONS:
        safe_patterns = [
            rf'[\s,\.]{abbrev_lower}[\s,\.\d]',
            rf'[\s,\.]{abbrev_lower}$',
        ]
        for pattern in safe_patterns:
            if re.search(pattern, note_lower):
                return state_code, None
    else:
        if state_code == 'MD':
            md_credential = re.search(r'(?:dr\.?|[a-z]{2,})\s*,?\s*md\b', note_lower)
            md_location = re.search(r'(?:lives?|resides?|from|in)\s+.*\bmd\b', note_lower)
            if md_credential and not md_location:
                pass
            else:
                strict_patterns = [
                    rf',\s*{abbrev_lower}\s*[.\s\d]',
                    rf',\s*{abbrev_lower}$',
                    rf'lives?\s+in\s+[\w\s,]+\b{abbrev_lower}\b',
                    rf'resides?\s+in\s+[\w\s,]+\b{abbrev_lower}\b',
                    rf'from\s+[\w\s,]+\b{abbrev_lower}\b',
                    rf'\b{abbrev_lower}\s+\d{{5}}\b',
                ]
                for pattern in strict_patterns:
                    if re.search(pattern, note_lower):
                        return state_code, None
        else:
            strict_patterns = [
                rf',\s*{abbrev_lower}\s*[.\s\d]',
                rf',\s*{abbrev_lower}$',
                rf'lives?\s+in\s+[\w\s,]+\b{abbrev_lower}\b',
                rf'resides?\s+in\s+[\w\s,]+\b{abbrev_lower}\b',
                rf'from\s+[\w\s,]+\b{abbrev_lower}\b',
                rf'\b{abbrev_lower}\s+\d{{5}}\b',
            ]
            for pattern in strict_patterns:
                if re.search(pattern, note_lower):
                    return state_code, None
    
    # CHECK 3: City name lookup
    sorted_cities = sorted(CITY_TO_STATE.keys(), key=len, reverse=True)
    
    for city in sorted_cities:
        if city in note_lower:
            mapped_state = CITY_TO_STATE[city]
            
            if mapped_state is None:
                return state_code, None
            
            if mapped_state == state_code:
                return state_code, None
            else:
                return mapped_state, f"Corrected state: Claude said {state_code} but city '{city}' maps to {mapped_state}"
    
    # CHECK 4: No geographic signal found ‚Äî likely hallucination
    return None, f"Cleared hallucinated state: {parsed_state} (no geographic signal in note)"


def validate_extracted_age(parsed_age, note_text):
    """
    Validate Claude's age extraction against the actual note text.
    Returns: (validated_age_or_None, log_message_or_None)
    """
    if parsed_age is None:
        return None, None
    
    note_lower = note_text.lower()
    
    age_patterns = [
        r'\b\d{1,3}[\s\-]*(?:year|yr|y/?o|years?\s*old)\b',
        r'\b(?:age|aged)\s*\d{1,3}\b',
        r'\b\d{1,3}[\s\-]*(?:yo|y\.o\.)\b',
        r'\b\d{1,3}\s*(?:f|m)\b',
        r'\b(?:f|m)\s*\d{1,3}\b',
    ]
    
    age_found = any(re.search(pattern, note_lower) for pattern in age_patterns)
    
    if age_found:
        return parsed_age, None
    else:
        return None, f"Cleared hallucinated age: {parsed_age}"


def validate_parsed_data(parsed, note_text):
    """
    Unified post-processing validator for parse_clinical_note output.
    Catches hallucinated states and ages by verifying against the original note.
    """
    validation_log = []
    
    # Validate STATE
    validated_state, state_msg = validate_extracted_state(parsed.get('state'), note_text)
    if parsed.get('state') and validated_state != str(parsed['state']).upper():
        if state_msg:
            validation_log.append(state_msg)
    parsed['state'] = validated_state
    
    # Validate AGE
    validated_age, age_msg = validate_extracted_age(parsed.get('age'), note_text)
    if parsed.get('age') and validated_age is None:
        if age_msg:
            validation_log.append(age_msg)
    parsed['age'] = validated_age
    
    # Store log
    parsed['_validation_log'] = validation_log
    
    return parsed


# Clinical note parser
def parse_clinical_note(note_text, db_a, db_b):
    """Parse clinical note using Claude API to extract structured data"""
    import anthropic
    
    # Get API key from secrets (for deployed app) or environment
    try:
        api_key = st.secrets.get("ANTHROPIC_API_KEY", None)
    except:
        api_key = None
    
    if not api_key:
        st.error("‚ö†Ô∏è Anthropic API key not configured. Add it to Streamlit secrets to enable note parsing.")
        return None
    
    # Get valid options from databases
    states = sorted(db_b['State'].unique().tolist())
    payers = sorted(db_a['Payer_Name'].unique().tolist())[:50]  # Top 50 for context
    drug_classes = sorted(db_b['Drug_Class'].unique().tolist())
    
    try:
        client = anthropic.Anthropic(api_key=api_key)
        
        message = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=1024,
            messages=[{
                "role": "user",
                "content": f"""Extract patient information from this clinical note. Return ONLY a JSON object.

**STRICT EXTRACTION RULES - READ CAREFULLY:**

You MUST return null for any field where the information is not EXPLICITLY written in the note.
DO NOT:
- Guess a state (like "PA") if no state or city is mentioned
- Guess an age (like "35") if no age is mentioned  
- Guess a payer if no insurance is mentioned
- Make up or infer ANY information

EXAMPLES OF CORRECT BEHAVIOR:
- Note says "45-year-old" ‚Üí age: 45
- Note does NOT mention age ‚Üí age: null (NOT a guess like 35)
- Note says "lives in Philadelphia" ‚Üí state: "PA"
- Note does NOT mention location ‚Üí state: null (NOT a guess like "PA")
- Note says "has Aetna" ‚Üí payer: "Aetna"
- Note does NOT mention insurance ‚Üí payer: null

CRITICAL: Look for insurance/payer information carefully. Examples:
- "Has Independence Blue Cross" ‚Üí payer: "Independence Blue Cross"
- "Has Highmark insurance" ‚Üí payer: "Highmark Blue Cross Blue Shield"
- "Aetna commercial plan" ‚Üí payer: "Aetna"
- "UnitedHealthcare" ‚Üí payer: "UnitedHealthcare"
- NO INSURANCE MENTIONED ‚Üí payer: null

JSON format:
{{
  "state": "two-letter state code or null if NO location mentioned",
  "payer": "insurance company name or null if NO insurance mentioned", 
  "drug_class": "medication class or null if NO specific drug requested",
  "diagnosis": "Chronic Migraine, Episodic Migraine, or Cluster Headache ‚Äî classify by FREQUENCY, not by drug requested",
  "headache_days_per_month": integer or null if not stated,
  "age": integer age or null if NOT explicitly stated,
  "prior_medications": [
    {{
      "name": "medication name (generic preferred)",
      "dose": "dose with units (e.g., '100mg daily', '80mg BID') or null if not stated",
      "duration_weeks": integer weeks or null if not stated (convert months to weeks: 1mo=4wks, 3mo=12wks),
      "reason_stopped": "reason discontinued (e.g., 'side effects - cognitive issues', 'ineffective', 'intolerance') or null if not stated"
    }}
  ],
  "confidence": "high if most fields found, medium if some missing, low if minimal info"
}}

PRIOR MEDICATION EXTRACTION RULES:
- Extract EACH medication that was tried/failed as a separate object
- Include the MAXIMUM dose reached (not starting dose)
- Convert durations to weeks: "3 months" = 12, "10 weeks" = 10, "6 weeks" = 6
- For reason_stopped, summarize the key issue (side effects, ineffective, intolerance, etc.)
- If dose/duration/reason not explicitly stated for a medication, use null for that field

EXAMPLES:
- "Topiramate 100mg daily for 12 weeks, stopped due to cognitive issues" ‚Üí
  {{"name": "topiramate", "dose": "100mg daily", "duration_weeks": 12, "reason_stopped": "cognitive side effects"}}
- "Tried propranolol but couldn't tolerate it" ‚Üí
  {{"name": "propranolol", "dose": null, "duration_weeks": null, "reason_stopped": "intolerance"}}
- "Failed amitriptyline 75mg" ‚Üí
  {{"name": "amitriptyline", "dose": "75mg", "duration_weeks": null, "reason_stopped": null}}

Common payers in database:
{', '.join(payers[:40])}

Valid drug classes:
{', '.join(drug_classes)}

Medication name to class mapping:
- Aimovig, Ajovy, Emgality (migraine), erenumab ‚Üí "CGRP mAbs"
- Emgality 300mg for CLUSTER HEADACHE ‚Üí "CGRP mAb (Cluster)" (NOT "CGRP mAbs")
- If diagnosis is Cluster Headache and medication is Emgality ‚Üí "CGRP mAb (Cluster)"
- Ubrelvy, ubrogepant ‚Üí "Gepants" (acute only)
- Zavzpret, zavegepant ‚Üí "Gepants" (acute only)
- Nurtec ODT, rimegepant for ACUTE/PRN use ‚Üí "Gepants"
- Nurtec ODT, rimegepant for PREVENTION ‚Üí "Gepants (Preventive)"
- Qulipta, atogepant ‚Üí "Qulipta" (preventive only)
- Botox, onabotulinumtoxinA ‚Üí "Botox"
- Vyepti, eptinezumab ‚Üí "Vyepti"
- For Cluster Headache prevention ‚Üí "CGRP mAb (Cluster)" or "Emgality (Cluster)"

CRITICAL - Nurtec indication detection:
- If note says "prevent", "prevention", "prophylaxis", "daily", "every other day", "EOD" ‚Üí "Gepants (Preventive)"
- If note says "acute", "PRN", "as needed", "rescue", "abort" ‚Üí "Gepants"
- If unclear, check diagnosis: Chronic Migraine often uses preventive, Episodic often uses acute
- Default to "Gepants (Preventive)" if requesting Nurtec for someone already on preventive therapy discussion

CRITICAL - Default preventive selection:
- If patient "wants prevention" or "wants something to prevent" WITHOUT naming a specific drug:
  ‚Üí Default to "CGRP mAbs" (first-line injectable preventive, most common PA request)
- Do NOT default to Botox unless explicitly mentioned - Botox is second-line and chronic migraine only
- Do NOT default to Vyepti unless explicitly mentioned - Vyepti requires IV infusion
- Qulipta is appropriate if patient prefers oral medication or has needle phobia

DRUG CLASS PRIORITY for unspecified preventive requests:
1. "CGRP mAbs" - Default choice (Aimovig, Ajovy, Emgality)
2. "Qulipta" - If oral preferred or needle concerns mentioned
3. "Botox" - ONLY if explicitly requested or patient has failed CGRP mAbs
4. "Vyepti" - ONLY if explicitly requested or patient needs IV option

CRITICAL - DIAGNOSIS CLASSIFICATION RULES:
The diagnosis MUST be based on headache FREQUENCY or clinician's stated diagnosis, NEVER on the drug requested.
- ‚â•15 headache days/month ‚Üí "Chronic Migraine"
- <15 headache days/month ‚Üí "Episodic Migraine"  
- Cluster symptoms (unilateral, autonomic features, short severe attacks) ‚Üí "Cluster Headache"
- If clinician explicitly writes "chronic migraine" ‚Üí "Chronic Migraine" (trust the clinician)
- If clinician explicitly writes "episodic migraine" ‚Üí "Episodic Migraine"
- DO NOT infer "Chronic Migraine" just because patient requests Botox ‚Äî Botox indication is checked separately
- DO NOT let the requested drug influence the diagnosis classification
- Example: "10 migraine days/month, requesting Botox" ‚Üí diagnosis: "Episodic Migraine", headache_days_per_month: 10
- Example: "20 headache days/month" ‚Üí diagnosis: "Chronic Migraine", headache_days_per_month: 20
- Extract headache_days_per_month as a separate integer whenever frequency is mentioned

Clinical note:
{note_text}

Return ONLY the JSON object. Use null for ANY field where information is not explicitly stated in the note. Do NOT fabricate or assume information."""
            }]
        )
        
        # Extract JSON from response
        response_text = message.content[0].text
        
        # Try to parse JSON
        try:
            parsed = json.loads(response_text)
            
            # Validate and fuzzy-match payer name
            if parsed.get('payer'):
                payer_input = parsed['payer'].lower().strip()
                all_payers = db_a['Payer_Name'].unique()
                
                # Try exact match first (case insensitive)
                exact_match = None
                for p in all_payers:
                    if p.lower() == payer_input:
                        exact_match = p
                        break
                
                # If no exact match, try partial matching
                if not exact_match:
                    for p in all_payers:
                        # Check if input is contained in database name or vice versa
                        if payer_input in p.lower() or p.lower() in payer_input:
                            exact_match = p
                            break
                
                # Update with matched name
                if exact_match:
                    parsed['payer'] = exact_match
            
            # POST-PROCESSING: Validate extracted values against original note
            parsed = validate_parsed_data(parsed, note_text)
            
            return parsed
        except:
            # If not valid JSON, try to extract it
            import re
            json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
            if json_match:
                parsed = json.loads(json_match.group())
                parsed = validate_parsed_data(parsed, note_text)
                return parsed
            else:
                st.error("Failed to parse API response")
                return None
                
    except Exception as e:
        st.error(f"API Error: {str(e)}")
        return None

# ============================================================================
# HIPAA ACKNOWLEDGMENT MODAL - Must acknowledge before using app
# ============================================================================
if 'hipaa_acknowledged' not in st.session_state:
    st.session_state.hipaa_acknowledged = False

if not st.session_state.hipaa_acknowledged:
    st.markdown("""
    <div style="background: linear-gradient(135deg, #4B0082 0%, #6A0DAD 100%); 
                color: white; padding: 2rem; border-radius: 12px; margin-bottom: 1rem; text-align: center;">
        <div style="font-size: 2rem; margin-bottom: 0.5rem;">üíä The Headache Vault</div>
        <div style="font-size: 1rem; opacity: 0.9;">Prior Authorization Automation Demo</div>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("""
    <div style="background: #FEF3C7; border: 2px solid #F59E0B; border-radius: 12px; padding: 1.5rem; margin: 1rem 0;">
        <div style="display: flex; align-items: flex-start; gap: 12px;">
            <span style="font-size: 32px;">‚ö†Ô∏è</span>
            <div>
                <div style="font-size: 1.25rem; font-weight: 700; color: #92400E; margin-bottom: 0.75rem;">
                    Important: Demo Environment ‚Äî NOT HIPAA Compliant
                </div>
                <div style="color: #78350F; font-size: 0.95rem; line-height: 1.6;">
                    <p style="margin-bottom: 0.75rem;">
                        This demonstration application uses external AI services (Anthropic Claude) and cloud hosting 
                        that have <strong>NOT been configured for HIPAA compliance</strong>.
                    </p>
                    <p style="margin-bottom: 0.75rem; font-weight: 600;">
                        üö´ DO NOT ENTER any Protected Health Information (PHI):
                    </p>
                    <ul style="margin: 0.5rem 0 0.75rem 1.25rem; padding: 0;">
                        <li>Patient names, dates of birth, or Social Security numbers</li>
                        <li>Medical record numbers or insurance member IDs</li>
                        <li>Specific dates of service or appointment dates</li>
                        <li>Addresses, phone numbers, or email addresses</li>
                    </ul>
                    <p style="margin-bottom: 0;">
                        ‚úÖ <strong>Safe to use:</strong> Age (not DOB), gender, state, insurance company name, 
                        diagnosis codes, medication names/doses, and de-identified treatment history.
                    </p>
                </div>
            </div>
        </div>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("""
    <div style="background: #F3F4F6; border-radius: 8px; padding: 1rem; margin: 1rem 0; font-size: 0.85rem; color: #4B5563;">
        <strong>About this Demo:</strong> The Headache Vault PA Engine demonstrates automated prior authorization 
        workflows for headache medications. Use sample data or fully de-identified scenarios only.
        <br><br>
        <strong>Production Version:</strong> A HIPAA-compliant production version with BAA coverage is planned for August 2026.
    </div>
    """, unsafe_allow_html=True)
    
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        if st.button("‚úÖ I Understand ‚Äî Continue to Demo", type="primary", use_container_width=True):
            st.session_state.hipaa_acknowledged = True
            st.rerun()
    
    st.stop()  # Prevent rest of app from loading until acknowledged

# ============================================================================
# GLOBAL HIPAA WARNING BANNER - Persistent at top of every page
# ============================================================================
st.markdown("""
<div style="background: linear-gradient(90deg, #DC2626 0%, #B91C1C 100%); 
            color: white; 
            padding: 10px 16px; 
            border-radius: 8px; 
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.9rem;">
    <span style="font-size: 20px;">‚ö†Ô∏è</span>
    <div>
        <strong>DEMO ENVIRONMENT ‚Äî NOT HIPAA COMPLIANT</strong>
        <span style="opacity: 0.9; margin-left: 8px;">
            Do NOT enter real patient information. Use de-identified or sample data only.
        </span>
    </div>
</div>
""", unsafe_allow_html=True)

# Header with title - using columns to add home button inline
title_col1, title_col2 = st.columns([9, 1])
with title_col1:
    st.markdown("""
    <div style="text-align: left; margin-bottom: 1rem;">
        <div class="main-header">The Headache Vault</div>
        <div class="sub-header">Prior Authorization Automation for Headache Medicine</div>
        <div style="color: #262730; font-size: 0.95rem; font-weight: 400; font-family: 'Source Sans Pro', sans-serif;">
            Infrastructure to Scale Specialist-Level Care
        </div>
    </div>
    """, unsafe_allow_html=True)
with title_col2:
    if st.button("üè†", key="home_btn", help="Return to Dashboard"):
        st.session_state.current_page = 'Dashboard'
        st.session_state.search_results = None
        st.session_state.show_pa_text = False
        st.rerun()

# ============================================================================
# PERSONA TOGGLE - Experience Mode Selector
# ============================================================================
toggle_col1, toggle_col2, toggle_col3 = st.columns([3, 6, 3])
with toggle_col2:
    mode_options = {
        'pcp': 'üë®‚Äç‚öïÔ∏è PCP / New to CGRPs (Show Guidance)',
        'specialist': '‚ö° Specialist (Fast Mode)'
    }
    
    # Create the toggle using radio buttons styled as a toggle
    selected_mode = st.radio(
        "Experience Level",
        options=['pcp', 'specialist'],
        format_func=lambda x: mode_options[x],
        horizontal=True,
        label_visibility="collapsed",
        key="mode_selector"
    )
    
    # Update session state if changed
    if selected_mode != st.session_state.user_mode:
        st.session_state.user_mode = selected_mode
        st.rerun()

# Show mode indicator
if st.session_state.user_mode == 'pcp':
    st.markdown("""
    <div style="text-align: center; margin: 0.5rem 0 1rem 0;">
        <span style="background: #F0FFF4; color: #276749; padding: 0.35rem 0.75rem; border-radius: 20px; font-size: 0.8rem; font-weight: 500;">
            üìò Guidance Mode Active ‚Äî Tips and learning moments will appear throughout
        </span>
    </div>
    """, unsafe_allow_html=True)
else:
    st.markdown("""
    <div style="text-align: center; margin: 0.5rem 0 1rem 0;">
        <span style="background: #EBF8FF; color: #2B6CB0; padding: 0.35rem 0.75rem; border-radius: 20px; font-size: 0.8rem; font-weight: 500;">
            ‚ö° Fast Mode Active ‚Äî Clean data, no interruptions
        </span>
    </div>
    """, unsafe_allow_html=True)

# Page Navigation
col1, col2, col3, col4, col5 = st.columns([2,2,2,2,6])
with col1:
    if st.button("üìä Dashboard", use_container_width=True, type="primary" if st.session_state.current_page == 'Dashboard' else "secondary"):
        st.session_state.current_page = 'Dashboard'
        st.rerun()
with col2:
    if st.button("üîç Search", use_container_width=True, type="primary" if st.session_state.current_page == 'Search' else "secondary"):
        st.session_state.current_page = 'Search'
        st.rerun()
with col3:
    if st.button("üìã Paste Notes", use_container_width=True, type="primary" if st.session_state.current_page == 'Paste Notes' else "secondary"):
        st.session_state.current_page = 'Paste Notes'
        st.rerun()

st.markdown("---")

# ============================================================================
# DASHBOARD PAGE
# ============================================================================
if st.session_state.current_page == 'Dashboard':
    
    # Hero Stats
    st.markdown("### üìä Coverage Statistics")
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.markdown("""
        <div class="stat-card" style="background: linear-gradient(135deg, #4B0082 0%, #6A0DAD 100%); padding: 1.5rem; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(75, 0, 130, 0.3);">
            <div class="stat-number" style="font-size: 2.75rem; font-weight: 800; margin: 0;"><span style="color: #FFFFFF !important; text-shadow: 1px 1px 3px rgba(0,0,0,0.4);">752</span></div>
            <div class="stat-label" style="font-size: 1rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 0.5rem;"><span style="color: #E6E6FA !important; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">Payer Policies</span></div>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div class="stat-card" style="background: linear-gradient(135deg, #4B0082 0%, #6A0DAD 100%); padding: 1.5rem; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(75, 0, 130, 0.3);">
            <div class="stat-number" style="font-size: 2.75rem; font-weight: 800; margin: 0;"><span style="color: #FFFFFF !important; text-shadow: 1px 1px 3px rgba(0,0,0,0.4);">1,088</span></div>
            <div class="stat-label" style="font-size: 1rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 0.5rem;"><span style="color: #E6E6FA !important; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">Payers Covered</span></div>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
        <div class="stat-card" style="background: linear-gradient(135deg, #4B0082 0%, #6A0DAD 100%); padding: 1.5rem; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(75, 0, 130, 0.3);">
            <div class="stat-number" style="font-size: 2.75rem; font-weight: 800; margin: 0;"><span style="color: #FFFFFF !important; text-shadow: 1px 1px 3px rgba(0,0,0,0.4);">50</span></div>
            <div class="stat-label" style="font-size: 1rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 0.5rem;"><span style="color: #E6E6FA !important; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">States</span></div>
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown("""
        <div class="stat-card" style="background: linear-gradient(135deg, #4B0082 0%, #6A0DAD 100%); padding: 1.5rem; border-radius: 12px; text-align: center; box-shadow: 0 4px 6px rgba(75, 0, 130, 0.3);">
            <div class="stat-number" style="font-size: 2.75rem; font-weight: 800; margin: 0;"><span style="color: #FFFFFF !important; text-shadow: 1px 1px 3px rgba(0,0,0,0.4);">8</span></div>
            <div class="stat-label" style="font-size: 1rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-top: 0.5rem;"><span style="color: #E6E6FA !important; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">Drug Classes</span></div>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<br>", unsafe_allow_html=True)
    
    # What's New Banner
    st.info("üéâ **What's New:** AI Clinical Note Parsing now available! Parse unstructured notes in seconds.")
    
    # System Status
    st.markdown("<br>", unsafe_allow_html=True)
    st.markdown("### üîß System Status")
    
    col1, col2, col3 = st.columns(3)
    with col1:
        st.success("üü¢ **All Systems Operational**")
    with col2:
        st.info("‚ö° **Response Time:** <2 seconds")
    with col3:
        st.info("üìÖ **Last Updated:** January 15, 2026")
    
    # Feature Highlights
    st.markdown("<br>", unsafe_allow_html=True)
    st.markdown("### ‚ú® Platform Features")
    
    feature_col1, feature_col2 = st.columns(2)
    
    with feature_col1:
        st.markdown("""
        **Core Capabilities:**
        - ‚ö° 2-second PA policy lookups
        - ü§ñ AI-powered clinical note parsing  
        - üìã One-click appeal templates
        - üèÜ Gold Card status tracking
        - üìä Step therapy requirements
        - üîç ICD-10 code lookup
        """)
    
    with feature_col2:
        st.markdown("""
        **Clinical Intelligence:**
        - ‚úÖ AHS 2021/2024 Guidelines
        - ‚úÖ ACP 2025 Guidelines
        - ‚úÖ ICHD-3 Diagnostic Criteria
        - ‚úÖ MOH Risk Screening
        - ‚úÖ Pediatric Age Checks
        - ‚úÖ State Regulatory Framework
        """)

# ============================================================================
# SEARCH PAGE
# ============================================================================
elif st.session_state.current_page == 'Search':
    
    # ========================================================================
    # PA TEXT GENERATOR - Show at TOP when active
    # ========================================================================
    if st.session_state.show_pa_text and st.session_state.search_results is not None:
        results = st.session_state.search_results
        if len(results) > 0:
            row = results.iloc[0]
            
            # Get values safely
            headache_type = st.session_state.get('headache_type', 'Chronic Migraine')
            diag = st.session_state.parsed_data.get('diagnosis', headache_type) if 'parsed_data' in st.session_state else headache_type
            age = st.session_state.get('patient_age')
            if age is None:
                age = 35  # Default adult age if not specified
            drug = st.session_state.get('selected_drug', row['Drug_Class'])
            state = row['State']
            
            # Check if pediatric patient
            is_pediatric = age < 18
            
            # Get parsed prior medications if available
            prior_meds = []
            if 'parsed_data' in st.session_state and st.session_state.parsed_data.get('prior_medications'):
                prior_meds = st.session_state.parsed_data.get('prior_medications', [])
            
            st.markdown("### üìù Prior Authorization Documentation")
            
            # Close button to dismiss PA
            if st.button("‚úï Close PA Letter", key="close_pa"):
                st.session_state.show_pa_text = False
                st.rerun()
            
            # Show pediatric alert if applicable
            if is_pediatric:
                st.warning(f"‚ö†Ô∏è **Pediatric Patient (Age {age})** ‚Äî FDA approval and dosing considerations included in PA letter.")
            
            # Determine ICD-10 code based on diagnosis
            icd10_codes = {
                'Chronic Migraine': 'G43.709',
                'Episodic Migraine': 'G43.009', 
                'Cluster Headache': 'G44.009'
            }
            icd10_code = icd10_codes.get(diag, 'G43.709')
            
            if st.session_state.user_mode == 'pcp':
                st.markdown("""
                <div class="learning-moment">
                    <div class="learning-moment-title">üí° PA Documentation Tips</div>
                    <div class="learning-moment-content">
                        <strong>Keys to approval:</strong> Be specific about medication names, exact dosages, 
                        trial durations with dates, and clear failure reasons. Vague language like 
                        "tried several medications" or "adequate trial" often leads to denials.
                    </div>
                </div>
                """, unsafe_allow_html=True)
                
                # Build pediatric section if needed
                pediatric_section = ""
                if is_pediatric:
                    pediatric_section = f"""
PEDIATRIC CONSIDERATIONS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Patient Age: {age} years (Pediatric)

FDA-Approved CGRP Medications for Pediatric Migraine Prevention:
‚Ä¢ Aimovig (erenumab): Approved for ages 12+ for migraine prevention
‚Ä¢ Ajovy (fremanezumab): Approved for ages 12+ for migraine prevention  
‚Ä¢ Emgality (galcanezumab): Approved for ages 12+ for migraine prevention

Dosing: Standard adult dosing is appropriate for patients ‚â•12 years.

This patient meets age criteria for FDA-approved CGRP therapy.

"""
                
                pa_text = f"""‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
              PRIOR AUTHORIZATION REQUEST - {drug.upper()}
              Generated: {datetime.now().strftime('%B %d, %Y')}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

PATIENT INFORMATION
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Diagnosis: {diag}
ICD-10 Code: {icd10_code}
Patient Age: {age} years{" (PEDIATRIC)" if is_pediatric else ""}
{pediatric_section}
REQUESTED MEDICATION
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Drug Class: {drug}
Payer: {row['Payer_Name']}
Line of Business: {row['LOB']}
State: {state}

"""
                # Inject formulary status into PCP PA letter
                _pa_vault_id = row.get('Vault_Payer_ID', '')
                _pa_drug_cls = row.get('Drug_Class', '')
                _pa_sel_drug = extract_selected_drug_name(st.session_state.get('patient_context', {}) or {})
                if _pa_vault_id and _pa_drug_cls and not formulary_tier_map.empty:
                    _pa_tier = lookup_formulary_for_policy(formulary_tier_map, _pa_vault_id, _pa_drug_cls)
                    if not _pa_tier.empty:
                        pa_text += "FORMULARY STATUS\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
                        if _pa_sel_drug:
                            _sel_rows = _pa_tier[_pa_tier['Drug_Name'] == _pa_sel_drug]
                            if not _sel_rows.empty:
                                _s = _sel_rows.iloc[0]
                                _st_val = _s.get('Formulary_Status', 'Unknown')
                                _t_val = _s.get('Tier', '‚Äî')
                                pa_text += f"Requested Drug: {_pa_sel_drug} ({_st_val}, {_t_val})\n"
                                if _st_val in ('Non-Preferred', 'Restricted', 'Excluded'):
                                    _pref = _pa_tier[_pa_tier['Formulary_Status'] == 'Preferred']
                                    if not _pref.empty:
                                        _alt = _pref.iloc[0]
                                        pa_text += f"Preferred Alternative: {_alt['Drug_Name']} ({_alt.get('Tier', '‚Äî')})\n"
                                    pa_text += "\nClinical justification for non-preferred agent:\n"
                                    pa_text += "‚Ä¢ [Patient has failed/is intolerant to preferred agent]\n"
                                    pa_text += "‚Ä¢ [Specific clinical reason for this drug over preferred]\n"
                        else:
                            for _, _fr in _pa_tier.iterrows():
                                pa_text += f"  {_fr.get('Drug_Name','?')}: {_fr.get('Formulary_Status','?')} ({_fr.get('Tier','‚Äî')})\n"
                        pa_text += "\n"

                if row['Step_Therapy_Required'] == 'Yes':
                    step_req = row.get('Step_1_Requirement', 'Prior oral preventive trials required')
                    step_dur = row.get('Step_1_Duration', 'Per policy requirements')
                    pa_text += f"""STEP THERAPY REQUIREMENTS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Policy Requirement: {step_req}
Required Duration: {step_dur}

"""
                    # Check for enriched medication trial data first
                    # Use selected_policy_idx from session state, default to 0
                    policy_idx = st.session_state.get('selected_policy_idx', 0)
                    session_key = f"medication_trials_{policy_idx}"
                    if session_key in st.session_state and st.session_state[session_key]:
                        medication_trials = st.session_state[session_key]
                        pa_text += """DOCUMENTED PRIOR MEDICATION TRIALS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"""
                        for i, trial in enumerate(medication_trials, 1):
                            # Format each trial with available details
                            trial_line = f"  {i}. {trial.medication_name}"
                            if trial.drug_class:
                                trial_line += f" ({trial.drug_class})"
                            pa_text += trial_line + "\n"
                            
                            details = []
                            if trial.dose:
                                details.append(f"Dose: {trial.dose}")
                            if trial.duration_weeks:
                                details.append(f"Duration: {trial.duration_weeks} weeks")
                            if trial.reason_stopped:
                                details.append(f"Discontinued: {trial.reason_stopped}")
                            
                            if details:
                                pa_text += f"     ‚Üí {' | '.join(details)}\n"
                            pa_text += "\n"
                        
                        pa_text += """  ‚úì Patient has completed required step therapy trials as documented above.

"""
                    # Fall back to simple medication list if no enriched data
                    elif prior_meds:
                        pa_text += """DOCUMENTED PRIOR MEDICATION TRIALS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"""
                        for i, med in enumerate(prior_meds, 1):
                            # Handle both string and dict formats
                            if isinstance(med, str):
                                med_line = med
                            elif isinstance(med, dict):
                                med_line = med.get('name', 'Unknown')
                                details = []
                                if med.get('dose'):
                                    details.append(med['dose'])
                                if med.get('duration_weeks'):
                                    details.append(f"{med['duration_weeks']} weeks")
                                if med.get('reason_stopped'):
                                    details.append(f"D/C: {med['reason_stopped']}")
                                if details:
                                    med_line += f" - {', '.join(details)}"
                            else:
                                med_line = str(med)
                            pa_text += f"  {i}. {med_line}\n"
                        pa_text += """
  ‚úì Patient has completed required step therapy trials as documented above.

"""
                    else:
                        pa_text += """PRIOR MEDICATION TRIALS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  [Document each failed medication with:]
  ‚Ä¢ Drug name and maximum dose reached
  ‚Ä¢ Start and end dates (minimum 8 weeks)
  ‚Ä¢ Specific reason for discontinuation

"""
                pa_text += f"""
CLINICAL RATIONALE
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Patient has documented history of {diag} with inadequate response 
to conventional preventive therapies. {drug} is medically necessary 
due to:
‚Ä¢ Failure/intolerance of prior preventive medications as documented above
‚Ä¢ Significant impact on daily functioning and quality of life
‚Ä¢ No contraindications to requested therapy

REFERENCES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
This request aligns with:
‚Ä¢ American Headache Society Consensus Statement (2021)
‚Ä¢ ICHD-3 Diagnostic Criteria
‚Ä¢ AAN/AHS Practice Guidelines

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
            else:
                # Specialist compact mode
                pediatric_note = " [PEDIATRIC - FDA approved 12+]" if is_pediatric else ""
                pa_text = f"""PRIOR AUTHORIZATION REQUEST
{datetime.now().strftime('%Y-%m-%d')} | {row['Payer_Name']} | {state}

Dx: {diag} ({icd10_code})
Age: {age}y{pediatric_note}
Rx: {drug} ({row['Medication_Category']})
LOB: {row['LOB']}
"""
                # Inject compact formulary status for specialist mode
                if _pa_vault_id and _pa_drug_cls and not formulary_tier_map.empty:
                    _sp_tier = lookup_formulary_for_policy(formulary_tier_map, _pa_vault_id, _pa_drug_cls)
                    if not _sp_tier.empty and _pa_sel_drug:
                        _sp_sel = _sp_tier[_sp_tier['Drug_Name'] == _pa_sel_drug]
                        if not _sp_sel.empty:
                            _sp_s = _sp_sel.iloc[0]
                            pa_text += f"Formulary: {_pa_sel_drug} ‚Üí {_sp_s.get('Formulary_Status','?')} ({_sp_s.get('Tier','‚Äî')})\n"

                if row['Step_Therapy_Required'] == 'Yes':
                    step_req = row.get('Step_1_Requirement', 'Prior preventive')
                    step_dur = row.get('Step_1_Duration', 'Per policy')
                    pa_text += f"""
Step Therapy: REQUIRED ({step_req}, {step_dur})
"""
                    # Add prior meds in compact format
                    if prior_meds:
                        pa_text += "Prior Trials:\n"
                        for med in prior_meds:
                            # Handle both string and dict formats
                            if isinstance(med, str):
                                med_line = med
                            elif isinstance(med, dict):
                                med_line = med.get('name', 'Unknown')
                                if med.get('dose'):
                                    med_line += f" {med['dose']}"
                                if med.get('duration_weeks'):
                                    med_line += f" x{med['duration_weeks']}wk"
                                if med.get('reason_stopped'):
                                    med_line += f" ‚Üí {med['reason_stopped']}"
                            else:
                                med_line = str(med)
                            pa_text += f"  ‚Ä¢ {med_line}\n"
                    pa_text += "Status: Step therapy completed\n"
                else:
                    pa_text += "\nStep Therapy: Not required\n"
                
                pa_text += "\nRefs: AHS 2024, ICHD-3, AAN Guidelines"
            
            st.code(pa_text, language=None)
            
            # Store PA text and context for email functionality
            st.session_state.pa_text_for_email = pa_text
            st.session_state.pa_email_context = {
                'drug': drug,
                'payer': row['Payer_Name'],
                'state': state,
                'diagnosis': diag
            }
            
            # Action buttons row
            col1, col2, col3 = st.columns(3)
            with col1:
                if st.button("üìã Copy to Clipboard", key="copy_pa", use_container_width=True):
                    st.toast("‚úÖ PA text copied!", icon="‚úÖ")
            with col2:
                if st.button("üìß Email to Me", key="email_pa", use_container_width=True):
                    st.session_state.show_email_form = True
                    st.rerun()
            with col3:
                if st.button("üîô Back to Results", key="back_to_results", use_container_width=True):
                    st.session_state.show_pa_text = False
                    st.rerun()
            
            # Show email form if requested
            if st.session_state.get('show_email_form', False):
                show_email_modal()
            
            st.markdown("---")
    
    # ========================================================================
    # SEARCH PAGE CONTENT
    # ========================================================================
    st.markdown("### üîç Policy Search")
    st.markdown("Search for prior authorization requirements by state, payer, and medication.")
    
    st.markdown("<br>", unsafe_allow_html=True)
    
    # ============================================================================
    # SIDEBAR FILTERS (uses SidebarHelper for defaults from PatientContext)
    # ============================================================================
    st.sidebar.header("üîç Search Filters")
    
    # HIPAA Warning in Sidebar
    st.sidebar.markdown("""
<div style="background: #FEF3C7; border: 1px solid #F59E0B; border-radius: 6px; padding: 8px 10px; margin-bottom: 12px; font-size: 0.75rem;">
    <strong style="color: #92400E;">‚ö†Ô∏è Demo Only</strong><br>
    <span style="color: #78350F;">Not HIPAA compliant. Do not enter real patient data.</span>
</div>
""", unsafe_allow_html=True)

    # State selection - add placeholder if state not detected
    states = sorted(db_b['State'].unique().tolist())
    ctx = SessionStateManager.get_context()
    
    # If state not specified, show placeholder option
    if ctx.state is None:
        state_options = ["-- Please Select State --"] + states
        state_index = 0  # Start on placeholder
    else:
        state_options = states
        state_index = states.index(ctx.state) if ctx.state in states else 0
    
    selected_state = st.sidebar.selectbox(
        "State",
        options=state_options,
        index=state_index,
        key="sidebar_state"
    )
    
    # Check if user still needs to select a state
    state_not_selected = selected_state == "-- Please Select State --"
    if state_not_selected:
        st.sidebar.error("‚ö†Ô∏è Please select a state to search")
        # Use placeholder options when no state selected
        payer_options = ['All Payers']
        state_drug_classes = ['CGRP mAbs']  # Default option
    else:
        # Payer selection based on selected state
        state_payers = db_b[db_b['State'] == selected_state]['Payer_Name'].unique().tolist()
        payer_options = ['All Payers'] + sorted(state_payers)
        # Drug class selection based on selected state
        state_drug_classes = sorted(db_b[db_b['State'] == selected_state]['Drug_Class'].unique().tolist())
    
    selected_payer = st.sidebar.selectbox(
        "Payer", 
        options=payer_options,
        index=SidebarHelper.get_payer_index(payer_options) if not state_not_selected else 0,
        key="sidebar_payer",
        disabled=state_not_selected
    )
    
    selected_drug = st.sidebar.selectbox(
        "Medication Class",
        options=state_drug_classes if state_drug_classes else ['CGRP mAbs'],
        index=SidebarHelper.get_drug_index(state_drug_classes) if not state_not_selected and state_drug_classes else 0,
        help=f"{len(state_drug_classes)} drug classes available" if not state_not_selected else "Select state first",
        key="sidebar_drug",
        disabled=state_not_selected
    )
    
    # Headache type
    headache_options = ["Chronic Migraine", "Episodic Migraine", "Cluster Headache"]
    headache_type = st.sidebar.radio(
        "Headache Type",
        options=headache_options,
        index=SidebarHelper.get_headache_index(headache_options),
        key="sidebar_headache"
    )

    # Patient age (from PatientContext) - use 40 as neutral default if not specified
    ctx = SessionStateManager.get_context()
    age_value = ctx.age if ctx.age is not None else 40
    patient_age = st.sidebar.number_input(
        "Patient Age (years)",
        min_value=1,
        max_value=120,
        value=age_value,
        help="Used to check pediatric prescribing restrictions" + (" (not detected - please verify)" if ctx.age is None else ""),
        key="sidebar_age"
    )
    # Search button
    st.sidebar.markdown("---")

    # Show quick stats
    total_in_state = len(db_b[db_b['State'] == selected_state])
    st.sidebar.markdown(f"""
<div style='background-color: white; padding: 0.75rem; border-radius: 8px; border-left: 4px solid #4B0082; margin: 0.5rem 0;'>
    <div style='color: #262730; font-weight: 600;'>üìä {total_in_state} policies in {selected_state}</div>
</div>
""", unsafe_allow_html=True)

    # Database coverage note
    st.sidebar.markdown("""
<div style='color: #5A5A5A; font-size: 0.85rem; margin-top: 0.5rem; font-style: italic;'>
    üí° Database: 752 policies across 50 states. Preventive gepant coverage expanding weekly.
</div>
""", unsafe_allow_html=True)

    # Search button - disabled if state not selected
    if state_not_selected:
        st.sidebar.button("üîé Search Policies", type="primary", use_container_width=True, disabled=True)
        search_clicked = False
    else:
        search_clicked = st.sidebar.button("üîé Search Policies", type="primary", use_container_width=True)

    # Main content area - show results from either search method
    # But DON'T show results if state hasn't been selected yet
    if state_not_selected:
        # Clear any cached results and show welcome message
        st.session_state.search_results = None
        st.markdown("""
<div style="background: linear-gradient(135deg, #EFF6FF 0%, #DBEAFE 100%); border: 2px solid #3B82F6; border-radius: 16px; padding: 2rem; margin: 2rem 0; text-align: center;">
    <div style="font-size: 3rem; margin-bottom: 1rem;">üîç</div>
    <div style="font-weight: 700; color: #1E40AF; font-size: 1.5rem; margin-bottom: 1rem;">
        Select a State to Search Payer Policies
    </div>
    <div style="color: #1E3A8A; font-size: 1.1rem; margin-bottom: 1.5rem;">
        Use the <strong>State</strong> dropdown in the sidebar to find policies specific to your patient's insurance.
    </div>
    <div style="color: #3B82F6; font-size: 0.95rem;">
        üí° Our database covers <strong>866 policies</strong> across <strong>50 states</strong> for all major payers.
    </div>
</div>
""", unsafe_allow_html=True)
    elif (search_clicked or st.session_state.search_results is not None) or st.session_state.get('show_results', False):
        if search_clicked:
            # Create DataCollectionState for quality scoring
            collection_state = DataCollectionState(
                state=selected_state if selected_state not in ['ALL', '-- Please Select State --'] else None,
                payer=selected_payer if selected_payer != 'All Payers' else None,
                drug_class=selected_drug
            )
            st.session_state.data_collection_state = collection_state
            
            # Show quality indicator
            score, desc = collection_state.get_search_quality_score()
            st.markdown(get_quality_indicator_html(score, desc), unsafe_allow_html=True)
            
            # Perform search with national fallback support
            query, fallback_used, fallback_message = search_policies_with_fallback(
                db_b,
                state=selected_state,
                payer=selected_payer if selected_payer != 'All Payers' else None,
                drug_class=selected_drug
            )
            
            # Filter by headache type
            if headache_type == "Cluster Headache":
                query = query[query['Drug_Class'].str.contains('Cluster', case=False, na=False)]
            elif headache_type == "Chronic Migraine":
                query = query[query['Medication_Category'].str.contains('Chronic|Preventive', case=False, na=False)]
            
            st.session_state.search_results = query
            st.session_state.patient_age = patient_age
            st.session_state.matched_payer = selected_payer if selected_payer != 'All Payers' else None
            st.session_state.fallback_used = fallback_used
            st.session_state.fallback_message = fallback_message
            st.session_state.show_pa_text = False
        
        results = st.session_state.search_results
        patient_age_display = st.session_state.get('patient_age', patient_age if 'patient_age' in dir() else 35)
        
        # Show fallback notice if applicable
        if st.session_state.get('fallback_used', False):
            # Extract payer name from message for error context
            fallback_msg = st.session_state.get('fallback_message', '')
            show_error("payer_not_found", payer=st.session_state.get('selected_payer', 'this payer'))
        
        if len(results) == 0:
            st.warning("‚ö†Ô∏è No policies found for this combination.")
            st.info("""
            **Possible reasons:**
            - This payer may not have a specific policy for this drug class
            - Preventive gepant policies (Nurtec, Qulipta) are still being audited for some states
            - Try selecting a different medication class or payer
            
            **Coverage notes:**
            - All PA payers have policies for: CGRP mAbs, Botox, Gepants (acute)
            - Preventive gepant coverage expanding weekly
            """)
        else:
            # Display summary
            st.markdown("---")
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("Payers Found", len(results['Payer_Name'].unique()))
            with col2:
                st.metric("Policies Identified", len(results))
            with col3:
                requires_step = (results['Step_Therapy_Required'] == 'Yes').sum()
                st.metric("Require Step Therapy", f"{requires_step}/{len(results)}")
            
            # Display each policy as a professional card
            # Sort: matched payer first, then alphabetical
            matched_payer = st.session_state.get('matched_payer')
            if matched_payer and 'Payer_Name' in results.columns:
                mp_lower = matched_payer.lower()
                results = results.copy()
                results['_payer_match'] = results['Payer_Name'].apply(
                    lambda p: 0 if (mp_lower in p.lower() or p.lower() in mp_lower) else 1
                )
                results = results.sort_values('_payer_match').drop(columns=['_payer_match'])
            
            for idx, row in results.iterrows():
                # Build policy card with container
                st.markdown(f"""
                <div class="policy-card">
                    <div class="policy-header">
                        <div>
                            <div class="policy-title">üè• {row['Payer_Name']}</div>
                            <span class="policy-badge">{row["State"]} | {row["LOB"]}</span>
                        </div>
                    </div>
                </div>
                """, unsafe_allow_html=True)
                
                # ‚îÄ‚îÄ Formulary Tier Map Section (v3.0) ‚îÄ‚îÄ
                vault_id = row.get('Vault_Payer_ID', '')
                drug_cls = row.get('Drug_Class', '')
                if vault_id and drug_cls and not formulary_tier_map.empty:
                    tier_data = lookup_formulary_for_policy(formulary_tier_map, vault_id, drug_cls)
                    if not tier_data.empty:
                        # Determine selected drug from parsed note or sidebar
                        selected_drug = extract_selected_drug_name(st.session_state.get('patient_context', {}) or {})
                        st.markdown(f'''<div class="policy-section"><div class="policy-section-title">üíä Formulary Coverage</div>
{build_formulary_html_table(tier_data, selected_drug)}
{get_confidence_disclaimer(tier_data)}
{get_preferred_drug_suggestion(tier_data, selected_drug)}
</div>''', unsafe_allow_html=True)
                
                # Step Therapy Section - use native Streamlit
                if row['Step_Therapy_Required'] == 'Yes':
                    st.markdown('<div class="policy-section"><div class="policy-section-title">Step Therapy Required</div>', unsafe_allow_html=True)
                    
                    step_req, step_dur = get_step_therapy_details(row); step_therapies = step_req.split(';')
                    durations = step_dur.split(';')
                    
                    # Check if details are missing
                    has_missing_info = (
                        'Not specified' in step_req or
                        'Trial duration not specified' in step_dur
                    )
                    
                    for i, (therapy, duration) in enumerate(zip(step_therapies, durations if len(durations) == len(step_therapies) else ['Trial required'] * len(step_therapies)), 1):
                        st.markdown(f"""
                        <div class="step-item">
                            <div class="step-number">{i}</div>
                            <div>
                                <strong style="color: #262730;">{therapy.strip()}</strong><br>
                                <small style="color: #708090;">{duration.strip()}</small>
                            </div>
                        </div>
                        """, unsafe_allow_html=True)
                    
                    # Add guidance if details are missing (always show)
                    if has_missing_info:
                        st.markdown("""
                        <div style="background: #FFF9E6; padding: 1rem; border-radius: 8px; border-left: 4px solid #FFD700; margin-top: 0.75rem;">
                            <strong style="color: #B8860B;">üí° Missing Details? Contact the Payer</strong><br>
                            <small style="color: #666; line-height: 1.6;">
                            When step therapy requirements aren't specified in our database:<br>
                            ‚Ä¢ Call the payer's PA department for specific requirements<br>
                            ‚Ä¢ Ask about trial duration, dosing, and failure criteria<br>
                            ‚Ä¢ Request their clinical policy bulletin (CPB) number<br>
                            ‚Ä¢ Document the conversation in your PA submission
                            </small>
                        </div>
                        """, unsafe_allow_html=True)
                    
                    # PCP MODE: Show additional documentation guidance
                    if st.session_state.user_mode == 'pcp' and not has_missing_info:
                        with st.expander("üìò New to step therapy documentation? Click here for tips", expanded=False):
                            st.markdown("#### üìù Documentation Best Practices")
                            st.markdown("**What payers want to see:**")
                            st.markdown("""
- **Specific medication names** ‚Äî Not "tried several medications"
- **Exact dosages** ‚Äî "Topiramate 100mg BID" not "adequate dose"  
- **Duration with dates** ‚Äî "60 days (Jan 1 - Mar 1, 2026)"
- **Outcome** ‚Äî "Failed due to [side effect/inefficacy]"
                            """)
                            st.markdown("**Example documentation:**")
                            st.info('"Patient completed 60-day trial of topiramate 100mg BID from 11/1/25 to 12/31/25. Treatment was discontinued due to cognitive side effects (word-finding difficulty) despite dose titration. Headache frequency remained at 14 days/month."')
                    

                    # ================================================================
                    # DRUG-DIAGNOSIS SAFETY CHECK ‚Äî Before evaluating criteria
                    # ================================================================
                    # Botox is ONLY for Chronic Migraine (‚â•15 days/month)
                    parsed_drug = st.session_state.get('parsed_data', {}).get('drug_class', '')
                    parsed_diagnosis = st.session_state.get('parsed_data', {}).get('diagnosis', '')
                    headache_days = st.session_state.get('parsed_data', {}).get('headache_days_per_month')
                    is_botox = parsed_drug and 'botox' in str(parsed_drug).lower()
                    is_chronic = parsed_diagnosis and 'chronic' in str(parsed_diagnosis).lower()
                    
                    # Botox flag fires if:
                    # 1. Frequency is stated and < 15 days/month (hard rule, overrides diagnosis label), OR
                    # 2. Diagnosis explicitly says non-chronic and no frequency to override
                    botox_frequency_fail = (headache_days is not None and int(headache_days) < 15)
                    botox_diagnosis_fail = (not is_chronic and headache_days is None)
                    
                    if is_botox and (botox_frequency_fail or botox_diagnosis_fail):
                        show_error("botox_needs_chronic")
                        if botox_frequency_fail:
                            st.markdown(f"""
                            <div style="background: #FFF3CD; padding: 0.75rem 1rem; border-radius: 8px; margin: 0.5rem 0; border-left: 4px solid #FFC107;">
                                <span style="color: #856404; font-weight: 600;">üìä Patient reports {headache_days} headache days/month</span><br>
                                <small style="color: #856404;">Botox requires ‚â•15 days/month for ‚â•3 months. Consider CGRP mAbs (Aimovig, Ajovy, Emgality) for episodic migraine instead.</small>
                            </div>
                            """, unsafe_allow_html=True)
                    
                    # ================================================================
                    # CRITERIA MET CHECKLIST - Show if patient meets requirements
                    # ================================================================
                    elif 'parsed_data' in st.session_state and st.session_state.parsed_data.get('prior_medications'):
                        prior_meds = st.session_state.parsed_data.get('prior_medications', [])
                        diagnosis = st.session_state.parsed_data.get('diagnosis', '')
                        
                        criteria_results = check_criteria_met(step_req, prior_meds, diagnosis)
                        
                        if criteria_results:
                            st.markdown("---")
                            st.markdown("##### ‚úÖ Patient Criteria Status (from clinical note)")
                            
                            all_met = all(met for _, met, _ in criteria_results)
                            
                            for requirement, met, details in criteria_results:
                                if met:
                                    st.markdown(f"""
                                    <div style="background: #D4EDDA; padding: 0.75rem 1rem; border-radius: 8px; margin: 0.5rem 0; border-left: 4px solid #28A745;">
                                        <span style="color: #155724; font-weight: 600;">‚úì {requirement}</span><br>
                                        <small style="color: #155724;">{details}</small>
                                    </div>
                                    """, unsafe_allow_html=True)
                                else:
                                    st.markdown(f"""
                                    <div style="background: #FFF3CD; padding: 0.75rem 1rem; border-radius: 8px; margin: 0.5rem 0; border-left: 4px solid #FFC107;">
                                        <span style="color: #856404; font-weight: 600;">‚ö†Ô∏è {requirement}</span><br>
                                        <small style="color: #856404;">{details}</small>
                                    </div>
                                    """, unsafe_allow_html=True)
                            
                            if all_met:
                                # Check if medication details (dose/duration/reason) are actually filled in
                                # If not, show a softer "classes verified" message instead of "PA Ready"
                                has_complete_details = all(
                                    isinstance(med, dict) and med.get('dose') and med.get('duration_weeks') and med.get('reason_stopped')
                                    for med in prior_meds if isinstance(med, dict)
                                )
                                if has_complete_details:
                                    show_error("approved")
                                else:
                                    st.markdown("""
                                    <div style="background: #E8F4FD; padding: 0.75rem 1rem; border-radius: 8px; margin: 0.5rem 0; border-left: 4px solid #3B82F6;">
                                        <span style="color: #1E40AF; font-weight: 600;">‚ÑπÔ∏è Required medication classes documented</span><br>
                                        <small style="color: #1E40AF;">Fill in dose, duration, and reason stopped below to generate PA letter.</small>
                                    </div>
                                    """, unsafe_allow_html=True)
                            else:
                                # Count what's missing for a more specific error
                                unmet_requirements = [req for req, met, _ in criteria_results if not met]
                                met_count = sum(1 for _, met, _ in criteria_results if met)
                                total_required = len(criteria_results)
                                
                                # Determine what types of medications are missing
                                missing_classes = []
                                for req, met, details in criteria_results:
                                    if not met:
                                        if 'preventive' in req.lower():
                                            missing_classes.append("oral preventive (e.g., topiramate, propranolol, amitriptyline)")
                                        elif 'triptan' in req.lower():
                                            missing_classes.append("triptan trial")
                                        elif 'verapamil' in req.lower() or 'lithium' in req.lower():
                                            missing_classes.append("verapamil or lithium")
                                
                                show_error("insufficient_trials", 
                                          current=met_count, 
                                          required=total_required,
                                          missing=", ".join(missing_classes) if missing_classes else "additional medication trials")
                    
                    st.markdown("</div>", unsafe_allow_html=True)
                else:
                    st.markdown("""
                    <div class="policy-section">
                        <div style="background: #F0FFF4; padding: 1rem; border-radius: 8px; border-left: 4px solid #10B981;">
                            <strong style="color: #10B981;">‚úÖ No Step Therapy Required</strong><br>
                            <small style="color: #666;">This medication can be prescribed without prior trials</small>
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                    
                    # PCP MODE: Explain what "no step therapy" means
                    if st.session_state.user_mode == 'pcp':
                        st.markdown("""
                        <div class="pro-tip">
                            <div class="pro-tip-title">üí° What this means for you</div>
                            <div class="pro-tip-content">
                                You can prescribe this medication directly without documenting failed trials of other drugs.
                                However, you still need to document medical necessity (diagnosis, severity, functional impact).
                            </div>
                        </div>
                        """, unsafe_allow_html=True)
                
                # Gold Card Status
                if pd.notna(row.get('Gold_Card_Available')) and row['Gold_Card_Available'] == 'Yes':
                    threshold_text = row.get('Gold_Card_Threshold', 'Check state requirements')
                    st.markdown(f"""
                    <div class="policy-section">
                        <div class="gold-card-badge">
                            üèÜ Gold Card Available
                        </div>
                        <div style="margin-top: 0.5rem; color: #666; font-size: 0.9rem;">
                            {threshold_text}
                        </div>
                    </div>
                    """, unsafe_allow_html=True)
                
                # ================================================================
                # GAP ANALYSIS - Show when step therapy is required and we have parsed data
                # ================================================================
                ready_for_pa = True  # Default to ready if no step therapy
                
                if row['Step_Therapy_Required'] == 'Yes' and 'parsed_data' in st.session_state:
                    prior_meds = st.session_state.parsed_data.get('prior_medications', [])
                    
                    if prior_meds:
                        # Convert to MedicationTrial objects
                        session_key = f"medication_trials_{idx}"
                        if session_key not in st.session_state:
                            st.session_state[session_key] = create_medication_trials_from_parsed(prior_meds)
                        
                        medication_trials = st.session_state[session_key]
                        
                        # Render gap analysis UI
                        with st.expander("üìã Complete Step Therapy Documentation", expanded=True):
                            ready_for_pa, updated_trials = render_gap_analysis_ui(
                                policy_row=row.to_dict(),
                                medication_trials=medication_trials,
                                unique_key=f"gap_{idx}"
                            )
                            
                            # Update session state with any changes
                            st.session_state[session_key] = updated_trials
                    else:
                        # No prior medications documented - show helpful guidance
                        st.markdown("""
                        <div style="background: #FEF3C7; border: 2px solid #F59E0B; border-radius: 12px; padding: 1.25rem; margin: 1rem 0;">
                            <div style="font-weight: 700; color: #92400E; font-size: 1rem; margin-bottom: 0.5rem;">
                                ‚ö†Ô∏è No Prior Medications Documented
                            </div>
                            <div style="color: #78350F;">
                                This payer requires step therapy documentation before approving this medication.
                            </div>
                        </div>
                        """, unsafe_allow_html=True)
                        
                        # Show next steps for no medications case
                        with st.expander("üìã What are my options?", expanded=True):
                            st.markdown("""
                            **Option 1: Add medication history to clinical note**
                            
                            If the patient has tried preventive medications, go to the **Paste Notes** page 
                            and include details like:
                            
                            ```
                            Previously tried topiramate 100mg daily for 12 weeks - discontinued due to 
                            cognitive side effects. Also failed propranolol 80mg BID for 8 weeks with 
                            inadequate response.
                            ```
                            
                            ---
                            
                            **Option 2: Request exception if contraindicated**
                            
                            If the patient cannot take the required step therapy medications due to:
                            - Cardiovascular conditions (beta-blockers)
                            - Pregnancy/childbearing potential (valproate, topiramate)  
                            - Drug interactions
                            - Prior serious adverse reaction
                            
                            You can submit a medical necessity exception request.
                            
                            ---
                            
                            **Option 3: Begin step therapy if appropriate**
                            
                            If clinically appropriate, start the patient on a required medication class. 
                            Most policies require 8+ weeks at therapeutic dose.
                            
                            ---
                            
                            **Option 4: Refer to specialist**
                            
                            A headache specialist can help navigate complex cases and provide 
                            supporting documentation for exceptions.
                            """)
                        
                        ready_for_pa = False
                
                # Single primary action button - Generate PA
                col1, col2 = st.columns([3, 9])
                with col1:
                    if ready_for_pa:
                        if st.button("üéØ Generate PA Letter", key=f"pa_{idx}", type="primary", use_container_width=True):
                            st.session_state.show_pa_text = True
                            st.session_state.selected_policy_idx = idx
                            st.rerun()
                    else:
                        # Show disabled button with guidance
                        st.button("üéØ Complete Details Above", key=f"pa_{idx}", type="secondary", use_container_width=True, disabled=True)
                        st.caption("Fill in missing medication details to enable PA generation")
                
                st.markdown("<br>", unsafe_allow_html=True)

# ============================================================================
# AI PARSER PAGE
# ============================================================================
elif st.session_state.current_page == 'Paste Notes':
    
    st.markdown("### ü§ñ AI Clinical Note Parser")
    st.markdown("Paste unstructured clinical notes and let AI extract structured patient data in seconds.")
    
    st.info("üí° **How it works:** Our AI parses your clinic notes to extract patient info, then validates against our policy database. You get the speed of AI with the reliability of deterministic rules.")
    
    # Example button
    col1, col2 = st.columns([1, 4])
    with col1:
        if st.button("üìã Load Example", use_container_width=True):
            example_note = """45-year-old female with chronic migraine, approximately 20 headache days per month. 
Lives in Philadelphia, Pennsylvania. Has Independence Blue Cross commercial insurance. 
Previously tried topiramate 100mg daily for 12 weeks - discontinued due to cognitive side effects. 
Also failed propranolol 80mg BID for 8 weeks - inadequate response with less than 30% reduction in headache frequency.
Patient is interested in trying Aimovig (erenumab) for migraine prevention."""
            st.session_state.clinical_note = example_note
            st.rerun()
    
    # Text area for clinical note
    clinical_note = st.text_area(
        "Clinical Note",
        value=st.session_state.get('clinical_note', ''),
        height=250,
        placeholder="Paste patient information here...\n\nExample:\n45yo F with chronic migraine, 20+ days/month. Lives in PA, has Highmark BCBS. Failed topiramate and propranolol. Considering Aimovig.",
        help="Include: location, insurance, diagnosis, medications tried, medication considering"
    )
    
   # Parse button
    if st.button("ü§ñ Parse Note with AI", type="primary", use_container_width=True):
        if not clinical_note.strip():
            st.warning("Please enter a clinical note to parse.")
        else:
            # Clear previous parsed data before new parse
            st.session_state.parsed_data = None
            st.session_state.data_collection_state = None
            
            with st.spinner("üß† Analyzing clinical note..."):
                parsed_data = parse_clinical_note(clinical_note, db_a, db_b)
                
                if parsed_data:
                    # Update unified patient context
                    SessionStateManager.set_from_ai_parse(parsed_data)
                    st.session_state.parsed_data = parsed_data  # Keep for backward compatibility
                    
                     # Create and store DataCollectionState for quality tracking
                    try:
                        collection_state = analyze_parsed_data(parsed_data)
                        st.session_state.data_collection_state = collection_state
                    except Exception as e:
                        # Fallback if parsing fails
                        collection_state = DataCollectionState()
                        st.session_state.data_collection_state = collection_state
                    
                    # Success celebration
                    st.balloons()
                    st.success("üéâ **Note Parsed Successfully!** Extracted patient data.")
                    
                    # Show quality indicator
                    if collection_state and hasattr(collection_state, 'get_search_quality_score'):
                        score, desc = collection_state.get_search_quality_score()
                        st.markdown(get_quality_indicator_html(score, desc), unsafe_allow_html=True)
                    else:
                        st.info("üìä Data extracted - proceed to Search to find policies.")
                    
                    # Show warning if state is missing
                    if collection_state and hasattr(collection_state, 'state') and not collection_state.state:
                        st.markdown("""
<div class="required-field-box">
    <div style="font-weight: 700; color: #DC2626; margin-bottom: 0.5rem;">
        üî¥ State Not Detected
    </div>
    <div style="color: #7F1D1D;">
        Please select state in the Search sidebar before searching policies.
    </div>
</div>
""", unsafe_allow_html=True)
                    
                    # Auto-scroll to results
                    # Scroll handled by anchor below
    
    # Display parsed data if available
    if 'parsed_data' in st.session_state:
        parsed = st.session_state.parsed_data
        
        st.markdown("---")
        st.markdown('<div id="parsed-results"></div>', unsafe_allow_html=True)
        st.markdown("### üìä Extracted Information")
        
        # Auto-scroll to this section
        st.markdown("""
        <script>
            const element = document.getElementById('parsed-results');
            if (element) {
                element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        </script>
        """, unsafe_allow_html=True)
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if parsed.get('state'):
                st.metric("State", parsed['state'])
            if parsed.get('age'):
                st.metric("Age", f"{parsed['age']} years")
        
        with col2:
            if parsed.get('diagnosis'):
                st.metric("Diagnosis", parsed['diagnosis'])
            if parsed.get('confidence'):
                conf_emoji = {"high": "üü¢", "medium": "üü°", "low": "üî¥"}
                st.metric("Confidence", f"{conf_emoji.get(parsed['confidence'], '‚ö™')} {parsed['confidence'].title()}")
        
        with col3:
            if parsed.get('drug_class'):
                st.metric("Medication", parsed['drug_class'])
        
        # Payer info with copy button
        if parsed.get('payer'):
            col1, col2 = st.columns([3,1])
            with col1:
                st.info(f"**Insurance:** {parsed['payer']}")
            with col2:
                if st.button("üìã Copy", key="copy_payer"):
                    st.toast("‚úÖ Payer copied!", icon="‚úÖ")
        
        # Prior medications with MedicationMatcher
        if parsed.get('prior_medications') and len(parsed['prior_medications']) > 0:
            st.markdown("**Prior Medications:**")
            
            # Handle both old format (list of strings) and new format (list of dicts)
            prior_meds = parsed['prior_medications']
            
            # Extract medication names for matching
            med_names = []
            med_details = {}  # Store details keyed by lowercase name
            for med in prior_meds:
                if isinstance(med, str):
                    med_names.append(med)
                elif isinstance(med, dict) and med.get('name'):
                    name = med['name']
                    med_names.append(name)
                    med_details[name.lower()] = med
            
            # Use MedicationMatcher to validate and enhance medication names
            failed_med_matches = medication_matcher.search_multiple(med_names, threshold=0.80)
            
            if failed_med_matches:
                # Group by drug class for step therapy analysis
                drug_classes_found = set()
                for match in failed_med_matches:
                    drug_classes_found.add(match['drug_class'])
                    confidence_indicator = "‚úì" if match['confidence'] >= 0.95 else "~"
                    
                    # Look up structured details if available
                    original_input = match.get('original_input', '').lower()
                    details = med_details.get(original_input, {})
                    
                    # Build display line
                    display_line = f"- {confidence_indicator} **{match['brand']}** ({match['generic']}) ‚Äî *{match['drug_class']}*"
                    
                    # Add dose/duration/reason if available
                    detail_parts = []
                    if details.get('dose'):
                        detail_parts.append(details['dose'])
                    if details.get('duration_weeks'):
                        detail_parts.append(f"{details['duration_weeks']} weeks")
                    if details.get('reason_stopped'):
                        detail_parts.append(f"stopped: {details['reason_stopped']}")
                    
                    if detail_parts:
                        display_line += f" | {' | '.join(detail_parts)}"
                    
                    st.markdown(display_line)
                
                # Show step therapy summary
                step_therapy_classes = {'Beta-blocker', 'Anticonvulsant', 'TCA', 'SNRI', 'CCB', 'ARB', 'ACE Inhibitor'}
                relevant_classes = drug_classes_found.intersection(step_therapy_classes)
                if relevant_classes:
                    st.success(f"‚úÖ **{len(relevant_classes)} preventive class(es) documented:** {', '.join(sorted(relevant_classes))}")
                
                # Show unmatched medications (if any)
                matched_originals = {m.get('original_input', '').lower() for m in failed_med_matches}
                unmatched = [name for name in med_names if name.lower() not in matched_originals]
                if unmatched:
                    st.warning(f"‚ö†Ô∏è Could not match: {', '.join(unmatched)}")
            else:
                # Fallback to simple list if no matches
                for med in prior_meds:
                    if isinstance(med, str):
                        st.markdown(f"- {med}")
                    elif isinstance(med, dict):
                        name = med.get('name', 'Unknown')
                        dose = med.get('dose', '')
                        dur = med.get('duration_weeks', '')
                        reason = med.get('reason_stopped', '')
                        details = [d for d in [dose, f"{dur} weeks" if dur else '', reason] if d]
                        st.markdown(f"- {name}" + (f" | {' | '.join(details)}" if details else ""))
        
        # Edit mode
        with st.expander("‚úèÔ∏è Edit Extracted Data", expanded=False):
            st.markdown("Review and modify the extracted information before searching:")
            
            # Handle state - if AI returned None, show warning and default to first state
            state_options = sorted(db_b['State'].unique().tolist())
            if parsed.get('state') and parsed.get('state') in state_options:
                state_index = state_options.index(parsed['state'])
            else:
                state_index = 0  # Default to first alphabetically (AL or ALL)
                if not parsed.get('state'):
                    show_error("state_required")
            
            edited_state = st.selectbox("State", options=state_options, index=state_index)
            
            # Filter payers by edited state
            state_payers = sorted(db_b[db_b['State'] == edited_state]['Payer_Name'].unique().tolist())
            
            # Try to match payer
            payer_index = 0
            if parsed.get('payer'):
                for i, p in enumerate(state_payers):
                    if parsed['payer'].lower() in p.lower() or p.lower() in parsed['payer'].lower():
                        payer_index = i
                        break
            
            edited_payer = st.selectbox("Payer", options=['All Payers'] + state_payers, index=payer_index)
            
            # Filter drugs by edited state
            state_drugs = sorted(db_b[db_b['State'] == edited_state]['Drug_Class'].unique().tolist())
            drug_index = 0
            parsed_drug = parsed.get('drug_class')
            
            if parsed_drug and parsed_drug in state_drugs:
                drug_index = state_drugs.index(parsed_drug)
            elif parsed_drug:
                # Handle cluster headache fallback - if cluster-specific drug not available, try CGRP mAbs
                if 'Cluster' in parsed_drug and 'CGRP mAbs' in state_drugs:
                    drug_index = state_drugs.index('CGRP mAbs')
                    st.info(f"‚ÑπÔ∏è '{parsed_drug}' not available in {edited_state}. Using 'CGRP mAbs' (Emgality is FDA-approved for cluster headache).")
                # If drug class not found but CGRP mAbs exists, default to that instead of Botox
                elif 'CGRP mAbs' in state_drugs:
                    drug_index = state_drugs.index('CGRP mAbs')
            
            edited_drug = st.selectbox("Drug Class", options=state_drugs, index=drug_index)
            
            diagnosis_options = ["Chronic Migraine", "Episodic Migraine", "Cluster Headache"]
            diag_index = 0
            if parsed.get('diagnosis') and parsed['diagnosis'] in diagnosis_options:
                diag_index = diagnosis_options.index(parsed['diagnosis'])
            
            edited_diagnosis = st.selectbox("Diagnosis", options=diagnosis_options, index=diag_index)
            
            # Handle age - if AI returned None, show warning
            if parsed.get('age'):
                age_value = parsed['age']
            else:
                age_value = 40  # Neutral default
                show_error("age_not_detected")
            
            edited_age = st.number_input("Age", min_value=1, max_value=120, value=age_value)
            
            # Save edits
            if st.button("üíæ Save Edits"):
                st.session_state.parsed_data.update({
                    'state': edited_state,
                    'payer': edited_payer,
                    'drug_class': edited_drug,
                    'diagnosis': edited_diagnosis,
                    'age': edited_age
                })
                st.success("‚úÖ Edits saved!")
                st.rerun()
        
        # Search button - conditional based on whether state is available
        state_available = parsed.get('state') is not None
        
        if state_available:
            # State is available - show normal search button
            if st.button("üîé Search with Extracted Data", type="primary", use_container_width=True):
                # Determine the drug class to search for
                search_drug_class = parsed.get('drug_class')
                
                # Handle cluster headache drug class fallback
                if search_drug_class and 'Cluster' in search_drug_class:
                    state_drugs = db_b[db_b['State'] == parsed.get('state')]['Drug_Class'].unique().tolist()
                    if search_drug_class not in state_drugs and 'CGRP mAbs' in state_drugs:
                        search_drug_class = 'CGRP mAbs'  # Fall back to CGRP mAbs for cluster
                
                # Perform search with national fallback support
                query, fallback_used, fallback_message = search_policies_with_fallback(
                    db_b,
                    state=parsed.get('state'),
                    payer=parsed.get('payer'),
                    drug_class=search_drug_class
                )
                
                # Filter by diagnosis - but DON'T double-filter if drug_class already contains the diagnosis
                if parsed.get('diagnosis') == "Cluster Headache":
                    # Only apply cluster filter if we actually have cluster-specific policies
                    if parsed.get('drug_class') and 'Cluster' not in parsed.get('drug_class', ''):
                        cluster_filtered = query[query['Drug_Class'].str.contains('Cluster', case=False, na=False)]
                        # Only use cluster filter if it returns results, otherwise keep CGRP mAbs
                        if not cluster_filtered.empty:
                            query = cluster_filtered
                elif parsed.get('diagnosis') == "Chronic Migraine":
                    # Only filter if needed
                    if not query.empty:
                        chronic_filtered = query[query['Medication_Category'].str.contains('Chronic|Preventive', case=False, na=False)]
                        if not chronic_filtered.empty:
                            query = chronic_filtered
                # Don't filter episodic - too aggressive
                
                st.session_state.search_results = query
                st.session_state.patient_age = parsed.get('age') if parsed.get('age') else None  # Don't default to 35
                st.session_state.matched_payer = parsed.get('payer')
                st.session_state.fallback_used = fallback_used
                st.session_state.fallback_message = fallback_message
                st.session_state.show_pa_text = False  # Reset PA display on new search
                st.session_state.current_page = 'Search'
                
                if fallback_used:
                    st.toast(f"Using national baseline policy", icon="‚ÑπÔ∏è")
                st.toast("üéâ Policy search complete! Found {} matching policies.".format(len(query)), icon="üéâ")
                st.rerun()
        else:
            # State not available - show guidance to user
            st.markdown("""
<div style="background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%); border: 2px solid #F59E0B; border-radius: 12px; padding: 1.25rem; margin: 1rem 0;">
    <div style="font-weight: 700; color: #92400E; font-size: 1.1rem; margin-bottom: 0.5rem;">
        üìç State Required for Policy Search
    </div>
    <div style="color: #78350F; margin-bottom: 1rem;">
        To find your patient's specific payer policies, please add the state using one of these options:
    </div>
    <div style="color: #78350F; padding-left: 1rem;">
        <strong>Option 1:</strong> Expand "‚úèÔ∏è Edit Extracted Data" above and select a state<br>
        <strong>Option 2:</strong> Go to the <strong>Search</strong> page and select a state in the sidebar
    </div>
</div>
""", unsafe_allow_html=True)
            # Show disabled button as visual cue
            st.button("üîé Select State to Search Policies", type="primary", use_container_width=True, disabled=True)

# ============================================================================
# CLINICAL TOOLS SECTION (Only on Search page)
# ============================================================================
if st.session_state.current_page == 'Search' and st.session_state.search_results is not None:
    st.markdown("---")
    
    # Clinical Tools in an expander - keeps UI clean
    with st.expander("üîß Clinical Tools", expanded=False):
        tool_col1, tool_col2 = st.columns(2)
        
        with tool_col1:
            st.markdown("##### ‚öïÔ∏è MOH Risk Assessment")
            st.markdown("Check if patient's acute medication use puts them at risk for medication overuse headache.")
            if st.button("Check MOH Risk", key="moh_btn", use_container_width=True):
                st.session_state.show_moh_check = True
        
        with tool_col2:
            st.markdown("##### üìä ICD-10 Code Lookup")
            st.markdown("Find the correct diagnosis codes for headache disorders.")
            if st.button("View ICD-10 Codes", key="icd_btn", use_container_width=True):
                # Show ICD-10 codes inline
                headache_type_val = st.session_state.get('headache_type', 'Chronic Migraine')
                if headache_type_val == "Cluster Headache":
                    icd_filter = icd10[icd10['ICD10_Code'].str.startswith('G44.0')]
                elif headache_type_val == "Chronic Migraine":
                    icd_filter = icd10[icd10['ICD10_Code'].str.contains('G43.7', regex=False)]
                else:
                    icd_filter = icd10[icd10['ICD10_Code'].str.startswith('G43')]
                
                st.dataframe(
                    icd_filter[['ICD10_Code', 'ICD10_Description', 'PA_Relevance']],
                    use_container_width=True,
                    hide_index=True
                )

# ============================================================================
# MOH CHECKER (Only on Search page)
# ============================================================================
if st.session_state.current_page == 'Search' and st.session_state.show_moh_check:
    st.markdown("---")
    st.markdown("### ‚öïÔ∏è Medication Overuse Headache (MOH) Screening")
    
    st.info("Track OTC medication use to identify patients at risk for medication overuse headache (ICHD-3 Section 8.2)")
    
    # Simple MOH calculator
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("**Simple Analgesics** (Threshold: ‚â•15 days/month)")
        simple_days = st.number_input(
            "Days per month using acetaminophen, ibuprofen, naproxen, or aspirin",
            min_value=0,
            max_value=31,
            value=0
        )
    
    with col2:
        st.markdown("**Combination Analgesics** (Threshold: ‚â•10 days/month)")
        combo_days = st.number_input(
            "Days per month using Excedrin, BC Powder, or caffeine-containing products",
            min_value=0,
            max_value=31,
            value=0
        )
    
    # Display MOH risk
    if simple_days >= 15 or combo_days >= 10:
        st.markdown('<div class="warning-box">‚ö†Ô∏è <strong>MOH RISK IDENTIFIED</strong><br>' +
                  'Patient meets ICHD-3 criteria for medication overuse. Consider:<br>' +
                  '‚Ä¢ ICD-10 Code: G44.41 (Drug-induced headache, NEC)<br>' +
                  '‚Ä¢ CGRP therapy (lower MOH risk per AHS 2021)<br>' +
                  '‚Ä¢ Medication withdrawal protocol</div>',
                  unsafe_allow_html=True)
    else:
        st.markdown('<div class="success-box">‚úÖ No medication overuse detected based on current usage pattern</div>',
                  unsafe_allow_html=True)
    
    # Show OTC medication reference
    with st.expander("üìö OTC Medication Reference"):
        st.dataframe(
            otc[['Medication_Name', 'MOH_Category', 'MOH_Threshold_Days_Per_Month', 'Caffeine_Content_mg']],
            use_container_width=True,
            hide_index=True
        )

# Production Footer with HIPAA Disclaimer
st.markdown("---")
st.markdown("""
<div style="background: #FEF2F2; border: 1px solid #FECACA; border-radius: 8px; padding: 16px; margin-bottom: 1.5rem;">
    <div style="font-weight: 700; color: #991B1B; margin-bottom: 8px; font-size: 0.9rem;">
        ‚öñÔ∏è Legal Disclaimer ‚Äî Please Read
    </div>
    <div style="font-size: 0.8rem; color: #7F1D1D; line-height: 1.5;">
        <strong>NOT HIPAA COMPLIANT:</strong> The Headache Vault Demo is a prototype for demonstration and 
        educational purposes only. This application uses external AI services (Anthropic Claude API) and 
        cloud hosting (Streamlit) that have NOT been configured for HIPAA compliance. Do not enter Protected 
        Health Information (PHI) including patient names, DOB, MRN, SSN, specific dates of service, or contact information.
        <br><br>
        <strong>NOT MEDICAL/LEGAL ADVICE:</strong> Information provided is for educational purposes only and does not 
        constitute medical, legal, or billing advice. Always verify payer requirements directly.
        <br><br>
        <strong>PRODUCTION VERSION:</strong> A HIPAA-compliant version with BAA coverage is planned for August 2026. 
        Contact info@headachevault.com for enterprise inquiries.
    </div>
</div>

<div class="production-footer">
    <div style="margin-bottom: 1rem;">
        <span class="footer-badge">üìä CMS Data Sources</span>
        <span class="footer-badge">üè• State DOI Verified</span>
        <span class="footer-badge" style="background: #FEF3C7; color: #92400E;">‚ö†Ô∏è Demo Only</span>
    </div>
    <div style="font-size: 0.9rem; color: #262730; margin-bottom: 1rem;">
        <strong style='color: #4B0082; font-size: 1.1rem;'>The Headache Vault PA Engine</strong><br>
        <span style='color: #5A5A5A;'>Demo v1.0 | February 2026</span>
    </div>
    <div style="font-size: 0.85rem; color: #5A5A5A; margin-bottom: 1rem;">
        Infrastructure to Scale Specialist-Level Care<br>
        <strong>752 payer policies</strong> ‚Ä¢ <strong>50 states</strong> ‚Ä¢ <strong>1,088 payers</strong><br>
        Coverage expanding weekly
    </div>
    <div style="font-size: 0.8rem; color: #708090;">
        Clinical logic based on <strong>AHS 2021/2024</strong>, <strong>ACP 2025</strong>, <strong>ICHD-3 Criteria</strong><br>
        ü§ñ Powered by <strong>Anthropic Claude AI</strong> | ‚ö° Average response time: <strong>&lt;2 seconds</strong>
    </div>
    <div style="margin-top: 1rem; font-size: 0.75rem; color: #999;">
        üìÖ Last Updated: January 15, 2026 | üîÑ Database refreshed daily<br>
        <span style="color: #DC2626;">‚ö†Ô∏è NOT FOR CLINICAL USE ‚Äî DEMONSTRATION ONLY</span>
    </div>
</div>
""", unsafe_allow_html=True)